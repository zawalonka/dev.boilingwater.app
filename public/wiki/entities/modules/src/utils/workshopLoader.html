<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>workshopLoader.js - Boiling Water Wiki</title>
  <link rel="stylesheet" href="/wiki/assets/styles.css" />
  <!-- Kekule CSS loaded lazily when molecule viewer is needed -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />
</head>
<body>
  <div class="wiki-layout">
    <div class="wiki-main">
      <header class="wiki-topbar">
        <details class="wiki-menu" aria-label="Menu">
          <summary>‚ò∞ Menu</summary>
          <nav class="wiki-menu-links">
            <div class="menu-section">
              <div class="menu-heading">Main</div>
              <a href="/wiki/index.html">üìö Main page</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Science</div>
              <a href="/wiki/entities/elements/index.html">‚öõÔ∏è Elements</a>
              <a href="/wiki/entities/compounds/index.html">üß™ Compounds</a>
              <a href="/wiki/entities/solutions/index.html">üíß Solutions</a>
              <a href="/wiki/entities/phases/index.html">‚ùÑÔ∏è Phases</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Game Structure</div>
              <a href="/wiki/entities/levels/index.html">üìä Levels</a>
              <a href="/wiki/entities/experiments/index.html">üî¨ Experiments</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Code Reference</div>
              <a href="/wiki/entities/formulas/index.html">üìê Formulas</a>
              <a href="/wiki/entities/processes/index.html">‚öôÔ∏è Processes</a>
              <a href="/wiki/entities/modules/index.html">üì¶ Modules</a>
              <a href="/wiki/entities/symbols/index.html">üî£ Symbols</a>
              <a href="/wiki/entities/public/index.html">üìÅ Public Files</a>
              <a href="/wiki/entities/assets/index.html">üñºÔ∏è Assets</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Repository</div>
              <a href="/wiki/entities/docs/index.html">üìñ Docs</a>
              <a href="/wiki/entities/scripts/index.html">üß∞ Scripts</a>
              <a href="/wiki/entities/styles/index.html">üé® Styles</a>
              <a href="/wiki/entities/root-files/index.html">üóÇÔ∏è Root Files</a>
            </div>
            <div class="wiki-menu-divider"></div>
            <a href="/">‚¨ÖÔ∏è Back to Game</a>
          </nav>
        </details>
        
        <nav class="breadcrumbs" aria-label="Breadcrumb">
          <a href="/wiki/../../../index.html">Main</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../index.html">Modules</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../src/index.html">src</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../src/utils/index.html">utils</a> <span class="breadcrumb-sep">‚Ä∫</span> <span>workshopLoader.js</span>
        </nav>
        <div class="wiki-topbar-title">workshopLoader.js</div>
      </header>
      <main class="wiki-content">
        
        <article class="wiki-article">
          
      
    <aside class="infobox">
      <div class="infobox-title">workshopLoader.js</div>
      
      <div class="infobox-row">
        <div class="infobox-label">Type</div>
        <div class="infobox-value">Module</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">File type</div>
        <div class="infobox-value">js</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Exports</div>
        <div class="infobox-value"><ul><li><a href="/wiki/entities/symbols/DEFAULT_WORKSHOP.html">DEFAULT_WORKSHOP</a></li><li><a href="/wiki/entities/symbols/applyWorkshopStyles.html">applyWorkshopStyles</a></li><li><a href="/wiki/entities/symbols/processWorkshop.html">processWorkshop</a></li><li><a href="/wiki/entities/symbols/validateWorkshopData.html">validateWorkshopData</a></li></ul></div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Imports</div>
        <div class="infobox-value"><a href="/wiki/entities/modules/src/constants/workshops.html">workshops.js</a></div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Imported by</div>
        <div class="infobox-value"><ul><li><a href="/wiki/entities/modules/src/App.html">App.jsx</a></li></ul></div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Used in</div>
        <div class="infobox-value"><ul><li><a href="/wiki/entities/modules/src/utils/workshopLoader.html">workshopLoader.js</a></li></ul></div>
      </div>
    
    </aside>
  
      <section class="section">
        
  <div class="entity-header">
    <h1>workshopLoader.js</h1>
    <p class="subtitle">Module</p>
  </div>

      </section>
      
    <section class="section">
      <h2>Educational notes</h2>
      <p>Workshop Loader Utility</p>
<p>Dynamically loads and manages workshop configurations (visual skins).</p>
<p>Usage:</p>
<p>const workshop = await loadWorkshop(&#39;pre-alpha-kitchen-1&#39;)</p>
<p>const processed = processWorkshop(workshop)</p>
<p>applyWorkshopStyles(processed)</p>
    </section>
  
      <section class="section" id="source-file">
        <h2>Source file</h2>
        <p><code>src\utils\workshopLoader.js</code></p>
        <details>
          <summary>View source code</summary>
          <pre class="line-numbers"><code class="language-javascript">import { AVAILABLE_WORKSHOPS, WORKSHOP_CONFIG, WORKSHOP_METADATA_TEMPLATE } from &#39;../constants/workshops&#39;

/**
 * Workshop Loader Utility
 *
 * Dynamically loads and manages workshop configurations (visual skins).
 *
 * Usage:
 *   const workshop = await loadWorkshop(&#39;pre-alpha-kitchen-1&#39;)
 *   const processed = processWorkshop(workshop)
 *   applyWorkshopStyles(processed)
 */
export async function loadWorkshop(workshopId) {
  try {
    let base = import.meta.env?.BASE_URL || &#39;/&#39;
    if (base.startsWith(&#39;/&#39;)) base = base.slice(1)

    const workshopUrl = new URL(`${base}assets/workshops/${workshopId}/workshop.json`, window.location.href).toString()
    const res = await fetch(workshopUrl)
    if (!res.ok) {
      throw new Error(`HTTP ${res.status} loading ${workshopUrl}`)
    }

    const workshopData = await res.json()

    // Optional: load effects.json if present (non-blocking)
    try {
      const effectsUrl = new URL(`${base}assets/workshops/${workshopId}/effects.json`, window.location.href).toString()
      const effectsRes = await fetch(effectsUrl)
      if (effectsRes.ok) {
        workshopData.effects = await effectsRes.json()
      }
    } catch (effectsError) {
      console.info(`No effects.json for workshop &#39;${workshopId}&#39; (optional): ${effectsError.message}`)
    }

    // Optional: load room.json if present (non-blocking)
    try {
      const roomUrl = new URL(`${base}assets/workshops/${workshopId}/room.json`, window.location.href).toString()
      const roomRes = await fetch(roomUrl)
      if (roomRes.ok) {
        workshopData.room = await roomRes.json()
        
        // Load the default burner configuration
        const defaultBurnerId = workshopData.room.defaults?.burner
        if (defaultBurnerId) {
          try {
            const burnerUrl = new URL(`${base}assets/workshops/${workshopId}/burners/${defaultBurnerId}.json`, window.location.href).toString()
            const burnerRes = await fetch(burnerUrl)
            if (burnerRes.ok) {
              workshopData.burner = await burnerRes.json()
            }
          } catch (burnerError) {
            console.warn(`Failed to load burner &#39;${defaultBurnerId}&#39;: ${burnerError.message}`)
          }
        }

        // Load the default AC unit configuration
        const defaultAcId = workshopData.room.defaults?.acUnit
        if (defaultAcId) {
          try {
            const acUrl = new URL(`${base}assets/workshops/${workshopId}/ac-units/${defaultAcId}.json`, window.location.href).toString()
            const acRes = await fetch(acUrl)
            if (acRes.ok) {
              workshopData.acUnit = await acRes.json()
            }
          } catch (acError) {
            console.warn(`Failed to load AC unit &#39;${defaultAcId}&#39;: ${acError.message}`)
          }
        }

        // Load the default air handler configuration
        const defaultAirHandlerId = workshopData.room.defaults?.airHandler
        if (defaultAirHandlerId) {
          try {
            const ahUrl = new URL(`${base}assets/workshops/${workshopId}/air-handlers/${defaultAirHandlerId}.json`, window.location.href).toString()
            const ahRes = await fetch(ahUrl)
            if (ahRes.ok) {
              workshopData.airHandler = await ahRes.json()
            }
          } catch (ahError) {
            console.warn(`Failed to load air handler &#39;${defaultAirHandlerId}&#39;: ${ahError.message}`)
          }
        }
      }
    } catch (roomError) {
      console.info(`No room.json for workshop &#39;${workshopId}&#39; (optional): ${roomError.message}`)
    }

    validateWorkshopData(workshopData)
    return workshopData
  } catch (error) {
    throw new Error(`Failed to load workshop &#39;${workshopId}&#39;: ${error.message}`)
  }
}

/**
 * Load a specific piece of equipment from a workshop
 * @param {string} workshopId - The workshop to load from
 * @param {&#39;ac-units&#39; | &#39;air-handlers&#39; | &#39;burners&#39;} equipmentType - Type of equipment
 * @param {string} equipmentId - The equipment ID (filename without .json)
 * @returns {Promise&lt;object|null&gt;} The equipment config or null if not found
 */
export async function loadEquipment(workshopId, equipmentType, equipmentId) {
  if (!workshopId || !equipmentType || !equipmentId) return null
  
  try {
    let base = import.meta.env?.BASE_URL || &#39;/&#39;
    if (base.startsWith(&#39;/&#39;)) base = base.slice(1)
    
    const equipmentUrl = new URL(
      `${base}assets/workshops/${workshopId}/${equipmentType}/${equipmentId}.json`,
      window.location.href
    ).toString()
    
    const res = await fetch(equipmentUrl)
    if (res.ok) {
      const config = await res.json()
      return config
    }
    console.warn(`Equipment not found: ${equipmentType}/${equipmentId} in ${workshopId}`)
    return null
  } catch (error) {
    console.warn(`Failed to load ${equipmentType}/${equipmentId}: ${error.message}`)
    return null
  }
}

export function validateWorkshopData(workshopData) {
  for (const field of WORKSHOP_CONFIG.requiredFields) {
    if (!(field in workshopData)) {
      throw new Error(`Missing required field: &#39;${field}&#39;`)
    }
  }

  if (!workshopData.name &amp;&amp; (!workshopData.metadata || !workshopData.metadata.name)) {
    throw new Error(`Workshop must have a &#39;name&#39; field`)
  }

  if (workshopData.colors &amp;&amp; typeof workshopData.colors === &#39;object&#39;) {
    for (const color of WORKSHOP_CONFIG.requiredColors) {
      if (!(color in workshopData.colors)) {
        console.warn(`Workshop warning: Missing color &#39;${color}&#39;. This may cause styling issues.`)
      }
    }
  } else {
    throw new Error(`&#39;colors&#39; field must be an object`)
  }

  if (workshopData.images &amp;&amp; typeof workshopData.images === &#39;object&#39;) {
    for (const image of WORKSHOP_CONFIG.requiredImages) {
      if (!(image in workshopData.images)) {
        throw new Error(`Missing required image &#39;${image}&#39; in workshop &#39;${workshopData.id}&#39;`)
      }
    }
    Object.entries(workshopData.images).forEach(([key, value]) =&gt; {
      if (typeof value === &#39;string&#39; &amp;&amp; value.startsWith(&#39;./&#39;)) {
        workshopData.images[key] = value.replace(&#39;./&#39;, `/assets/workshops/${workshopData.id}/`)
      }
    })
  } else {
    throw new Error(`&#39;images&#39; field must be an object`)
  }

  if (workshopData.effects &amp;&amp; typeof workshopData.effects !== &#39;object&#39;) {
    throw new Error(`&#39;effects&#39; field, when provided, must be an object`)
  }

  if (workshopData.metadata &amp;&amp; typeof workshopData.metadata !== &#39;object&#39;) {
    throw new Error(`&#39;metadata&#39; field must be an object`)
  }
}

export function processWorkshop(workshopData, parentWorkshop = null) {
  const normalizeEffects = (effects) =&gt; {
    const defaults = {
      steam: { enabled: false },
      flameGlow: { enabled: false },
      waterStream: { enabled: false }
    }
    return {
      steam: { ...defaults.steam, ...(effects?.steam || {}) },
      flameGlow: { ...defaults.flameGlow, ...(effects?.flameGlow || {}) },
      waterStream: { ...defaults.waterStream, ...(effects?.waterStream || {}) }
    }
  }

  // Extract burner wattage steps from new burner JSON or fallback to legacy workshop.json
  const getBurnerConfig = () =&gt; {
    // New system: burner loaded from burners/{id}.json
    if (workshopData.burner) {
      return {
        wattageSteps: workshopData.burner.wattageSteps || [0, 500, 1000, 2000],
        controlType: workshopData.burner.controlType || &#39;knob&#39;,
        maxWatts: workshopData.burner.thermalCharacteristics?.maxWatts || 2000,
        efficiencyPercent: workshopData.burner.thermalCharacteristics?.efficiencyPercent || 85
      }
    }
    // Legacy fallback: burnerControls in workshop.json
    if (workshopData.burnerControls?.wattageSteps) {
      return {
        wattageSteps: workshopData.burnerControls.wattageSteps,
        controlType: workshopData.burnerControls.wattageSteps.length &gt; 5 ? &#39;buttons&#39; : &#39;knob&#39;,
        maxWatts: Math.max(...workshopData.burnerControls.wattageSteps),
        efficiencyPercent: 85
      }
    }
    // Default
    return {
      wattageSteps: [0, 500, 1000, 2000],
      controlType: &#39;knob&#39;,
      maxWatts: 2000,
      efficiencyPercent: 85
    }
  }

  const inherited = parentWorkshop ? JSON.parse(JSON.stringify(parentWorkshop)) : {}

  return {
    id: workshopData.id,
    name: workshopData.name,
    metadata: {
      ...WORKSHOP_METADATA_TEMPLATE,
      ...workshopData.metadata
    },
    colors: {
      ...inherited.colors,
      ...workshopData.colors
    },
    images: {
      ...inherited.images,
      ...workshopData.images
    },
    typography: {
      ...inherited.typography,
      ...workshopData.typography
    },
    layout: {
      ...inherited.layout,
      ...workshopData.layout
    },
    effects: normalizeEffects(workshopData.effects),
    burnerConfig: getBurnerConfig(),
    room: workshopData.room || null,
    acUnit: workshopData.acUnit || null,
    airHandler: workshopData.airHandler || null
  }
}

export function applyWorkshopStyles(processedWorkshop) {
  const root = document.documentElement

  if (processedWorkshop.colors) {
    for (const [colorKey, colorValue] of Object.entries(processedWorkshop.colors)) {
      const cssVarName = `--workshop-${colorKey.replace(/_/g, &#39;-&#39;)}`
      root.style.setProperty(cssVarName, colorValue)
    }
  }

  if (processedWorkshop.typography) {
    for (const [typographyKey, value] of Object.entries(processedWorkshop.typography)) {
      const cssVarName = `--font-${typographyKey.replace(/_/g, &#39;-&#39;)}`
      if (typeof value === &#39;string&#39;) {
        root.style.setProperty(cssVarName, value)
      } else if (value &amp;&amp; typeof value === &#39;object&#39;) {
        for (const [propKey, propValue] of Object.entries(value)) {
          const varName = `--font-${typographyKey}-${propKey}`.replace(/_/g, &#39;-&#39;)
          root.style.setProperty(varName, propValue)
        }
      }
    }
  }
}

export async function preloadWorkshopImages(workshopData) {
  const effectAssets = []
  if (workshopData.effects?.steam?.asset &amp;&amp; typeof workshopData.effects.steam.asset === &#39;string&#39;) {
    effectAssets.push([&#39;steam&#39;, workshopData.effects.steam.asset])
  }

  const assets = [
    ...(workshopData.images ? Object.entries(workshopData.images) : []),
    ...effectAssets
  ]

  if (assets.length === 0) return

  const imagePromises = assets.map(([key, url]) =&gt; new Promise((resolve) =&gt; {
    const img = new Image()
    img.onload = () =&gt; resolve()
    img.onerror = () =&gt; {
      console.warn(`‚úó Failed to preload ${key}: ${url}`)
      resolve()
    }
    img.src = url
  }))

  await Promise.all(imagePromises)
}

export async function getAvailableWorkshops() {
  try {
    return Object.entries(AVAILABLE_WORKSHOPS).map(([id, meta]) =&gt; ({ id, name: meta.name }))
  } catch (error) {
    console.error(&#39;Failed to get available workshops:&#39;, error)
    return [{ id: WORKSHOP_CONFIG.defaultWorkshop, name: &#39;Default Workshop&#39; }]
  }
}

export async function getWorkshopsByLevel(levelId) {
  const available = await getAvailableWorkshops()
  const workshops = []

  for (const workshop of available) {
    try {
      const workshopData = await loadWorkshop(workshop.id)
      const minLevel = workshopData.minLevel || 1
      const maxLevel = workshopData.maxLevel || 999
      if (levelId &gt;= minLevel &amp;&amp; levelId &lt;= maxLevel) {
        workshops.push({ id: workshop.id, name: workshop.name, minLevel, maxLevel })
      }
    } catch (error) {
      console.warn(`Could not load workshop ${workshop.id}:`, error.message)
    }
  }

  return workshops
}

export async function getWorkshopForLevel(workshopId, levelId) {
  const available = await getAvailableWorkshops()

  for (const { id } of available) {
    try {
      const workshop = await loadWorkshop(id)
      if (
        workshop.metadata.scope === &#39;level&#39; &amp;&amp;
        workshop.metadata.workshopId === workshopId &amp;&amp;
        workshop.metadata.levelId === levelId
      ) {
        return workshop
      }
    } catch (_) {
      /* continue */
    }
  }

  for (const { id } of available) {
    try {
      const workshop = await loadWorkshop(id)
      if (workshop.metadata.scope === &#39;workshop&#39; &amp;&amp; workshop.metadata.workshopId === workshopId) {
        return workshop
      }
    } catch (_) {
      /* continue */
    }
  }

  console.warn(`No workshop skin found for workshop &#39;${workshopId}&#39;, level &#39;${levelId}&#39;. Using default.`)
  return await loadWorkshop(WORKSHOP_CONFIG.defaultWorkshop)
}

export async function initializeWorkshop(workshopId, options = {}) {
  const { parentWorkshopId = null, apply = true } = options

  try {
    const rawWorkshop = await loadWorkshop(workshopId)

    let parentWorkshop = null
    const parentId = parentWorkshopId || rawWorkshop.parentWorkshop
    if (parentId) {
      const parentData = await loadWorkshop(parentId)
      parentWorkshop = processWorkshop(parentData)
    }

    const processedWorkshop = processWorkshop(rawWorkshop, parentWorkshop)

    if (apply) {
      applyWorkshopStyles(processedWorkshop)
    }

    return processedWorkshop
  } catch (error) {
    console.error(`Failed to initialize workshop &#39;${workshopId}&#39;:`, error.message)
    return {
      id: &#39;fallback&#39;,
      name: &#39;Fallback&#39;,
      colors: {},
      images: {},
      typography: {}
    }
  }
}

export const DEFAULT_WORKSHOP = WORKSHOP_CONFIG.defaultWorkshop
</code></pre>
        </details>
      </section>
    
        </article>
      </main>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
  <script>
    // Lazy-load Kekule only when molecule viewer is expanded (saves bandwidth on low-end devices)
    (() => {
      let smilesDrawerLoaded = false
      let smilesDrawerLoading = false
      
      // Convert explicit SMILES like [CH3][CH](OH)[CH3] to standard like CC(O)C
      const explicitToStandard = (smiles) => {
        return smiles
          // Common organic groups - order matters (longer patterns first)
          .replace(/\[CH3\]/g, 'C')
          .replace(/\[CH2\]/g, 'C')
          .replace(/\[CH\]/g, 'C')
          .replace(/\[OH\]/g, 'O')
          .replace(/\[NH2\]/g, 'N')
          .replace(/\[NH\]/g, 'N')
          .replace(/\[SH\]/g, 'S')
          // Single atoms in brackets (keep aromatic lowercase)
          .replace(/\[C\]/g, 'C')
          .replace(/\[N\]/g, 'N')
          .replace(/\[O\]/g, 'O')
          .replace(/\[S\]/g, 'S')
          .replace(/\[P\]/g, 'P')
          .replace(/\[F\]/g, 'F')
          .replace(/\[Cl\]/g, 'Cl')
          .replace(/\[Br\]/g, 'Br')
          .replace(/\[I\]/g, 'I')
          // Bare atoms in branches - H is implicit in standard SMILES
          .replace(/\(OH\)/g, '(O)')
          .replace(/\(NH2\)/g, '(N)')
          .replace(/\(NH\)/g, '(N)')
          .replace(/\(SH\)/g, '(S)')
      }
      
      const loadSmilesDrawer = async () => {
        if (smilesDrawerLoaded) return
        if (smilesDrawerLoading) {
          return new Promise(resolve => {
            const check = setInterval(() => {
              if (smilesDrawerLoaded) { clearInterval(check); resolve() }
            }, 50)
          })
        }
        smilesDrawerLoading = true
        
        // Load SmilesDrawer from CDN (much simpler than Kekule)
        await new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = 'https://unpkg.com/smiles-drawer@2.1.7/dist/smiles-drawer.min.js'
          script.onload = resolve
          script.onerror = reject
          document.body.appendChild(script)
        })
        
        smilesDrawerLoaded = true
        smilesDrawerLoading = false
      }
      
      const initMolecule = async (node) => {
        if (node.dataset.initialized) return
        node.dataset.initialized = 'true'
        
        const rawSmiles = node.getAttribute('data-smiles')
        if (!rawSmiles) return
        
        // Convert explicit format to standard if needed
        const smiles = explicitToStandard(rawSmiles)
        
        try {
          await loadSmilesDrawer()
          
          const drawer = new SmilesDrawer.SvgDrawer({ 
            width: 300, 
            height: 200,
            explicitHydrogens: true,
            terminalCarbons: true,
            compactDrawing: false
          })
          
          console.log('Parsing SMILES:', rawSmiles, '->', smiles)
          SmilesDrawer.parse(smiles, (tree) => {
            console.log('Parse success, tree:', tree)
            const svgElement = drawer.draw(tree, null, 'light')
            console.log('SVG element:', svgElement)
            node.innerHTML = ''
            node.appendChild(svgElement)
          }, (err) => {
            console.error('SMILES parse error for "' + smiles + '":', err)
            node.innerHTML = '<code>' + rawSmiles + '</code>'
          })
        } catch (err) {
          console.error('SmilesDrawer load error:', err)
          node.innerHTML = '<code>' + smiles + '</code>'
        }
      }
      
      // Use IntersectionObserver for lazy loading when scrolled into view
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initMolecule(entry.target)
            observer.unobserve(entry.target)
          }
        })
      }, { rootMargin: '100px' })
      
      // Also handle <details> expansion for molecules inside collapsed sections
      document.addEventListener('toggle', (e) => {
        if (e.target.tagName === 'DETAILS' && e.target.open) {
          const molecules = e.target.querySelectorAll('[data-smiles]:not([data-initialized])')
          molecules.forEach(node => initMolecule(node))
        }
      }, true)
      
      // Observe all molecule nodes
      const init = () => {
        const nodes = document.querySelectorAll('[data-smiles]')
        nodes.forEach(node => observer.observe(node))
      }
      
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init)
      } else {
        init()
      }
    })()
  </script>
</body>
</html>