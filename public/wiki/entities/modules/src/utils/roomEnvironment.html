<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>roomEnvironment.js - Boiling Water Wiki</title>
  <link rel="stylesheet" href="/wiki/assets/styles.css" />
  <!-- Kekule CSS loaded lazily when molecule viewer is needed -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />
</head>
<body>
  <div class="wiki-layout">
    <div class="wiki-main">
      <header class="wiki-topbar">
        <details class="wiki-menu" aria-label="Menu">
          <summary>‚ò∞ Menu</summary>
          <nav class="wiki-menu-links">
            <div class="menu-section">
              <div class="menu-heading">Main</div>
              <a href="/wiki/index.html">üìö Main page</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Science</div>
              <a href="/wiki/entities/elements/index.html">‚öõÔ∏è Elements</a>
              <a href="/wiki/entities/compounds/index.html">üß™ Compounds</a>
              <a href="/wiki/entities/solutions/index.html">üíß Solutions</a>
              <a href="/wiki/entities/phases/index.html">‚ùÑÔ∏è Phases</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Game Structure</div>
              <a href="/wiki/entities/levels/index.html">üìä Levels</a>
              <a href="/wiki/entities/experiments/index.html">üî¨ Experiments</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Code Reference</div>
              <a href="/wiki/entities/formulas/index.html">üìê Formulas</a>
              <a href="/wiki/entities/processes/index.html">‚öôÔ∏è Processes</a>
              <a href="/wiki/entities/modules/index.html">üì¶ Modules</a>
              <a href="/wiki/entities/symbols/index.html">üî£ Symbols</a>
              <a href="/wiki/entities/public/index.html">üìÅ Public Files</a>
              <a href="/wiki/entities/assets/index.html">üñºÔ∏è Assets</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Repository</div>
              <a href="/wiki/entities/docs/index.html">üìñ Docs</a>
              <a href="/wiki/entities/scripts/index.html">üß∞ Scripts</a>
              <a href="/wiki/entities/styles/index.html">üé® Styles</a>
              <a href="/wiki/entities/root-files/index.html">üóÇÔ∏è Root Files</a>
              <a href="/wiki/entities/reports/changes-since-last-commit.html">üß≠ Changes</a>
            </div>
            <div class="wiki-menu-divider"></div>
            <a href="/">‚¨ÖÔ∏è Back to Game</a>
          </nav>
        </details>
        
        <nav class="breadcrumbs" aria-label="Breadcrumb">
          <a href="/wiki/../../../index.html">Main</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../index.html">Modules</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../src/index.html">src</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../src/utils/index.html">utils</a> <span class="breadcrumb-sep">‚Ä∫</span> <span>roomEnvironment.js</span>
        </nav>
        <div class="wiki-topbar-title">roomEnvironment.js</div>
      </header>
      <main class="wiki-content">
        
        <article class="wiki-article">
          
      
    <aside class="infobox">
      <div class="infobox-title">roomEnvironment.js</div>
      
      <div class="infobox-row">
        <div class="infobox-label">Type</div>
        <div class="infobox-value">Module</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">File type</div>
        <div class="infobox-value">js</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Exports</div>
        <div class="infobox-value"><ul><li><a href="/wiki/entities/symbols/addVaporToRoom.html">addVaporToRoom</a></li><li><a href="/wiki/entities/symbols/applyHeatToRoom.html">applyHeatToRoom</a></li><li><a href="/wiki/entities/symbols/createRoomState.html">createRoomState</a></li><li><a href="/wiki/entities/symbols/getAtmosphereKey.html">getAtmosphereKey</a></li><li><a href="/wiki/entities/symbols/getRoomSummary.html">getRoomSummary</a></li><li><a href="/wiki/entities/symbols/normalizeFormula.html">normalizeFormula</a></li><li><a href="/wiki/entities/symbols/simulateRoomStep.html">simulateRoomStep</a></li></ul></div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Imports</div>
        <div class="infobox-value"><a href="/wiki/entities/modules/src/utils/acUnitHandler.html">acUnitHandler.js</a>, <a href="/wiki/entities/modules/src/utils/airHandlerScrubber.html">airHandlerScrubber.js</a>, <span class="external-import">./physics/index.js</span></div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Imported by</div>
        <div class="infobox-value"><ul><li><a href="/wiki/entities/modules/src/hooks/useRoomEnvironment.html">useRoomEnvironment.js</a></li><li><a href="/wiki/entities/modules/src/hooks/useSimulationResultApplier.html">useSimulationResultApplier.js</a></li></ul></div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Used in</div>
        <div class="infobox-value"><ul><li><a href="/wiki/entities/modules/src/hooks/useRoomEnvironment.html">useRoomEnvironment.js</a></li><li><a href="/wiki/entities/modules/src/hooks/useSimulationResultApplier.html">useSimulationResultApplier.js</a></li><li><a href="/wiki/entities/modules/src/utils/roomEnvironment.html">roomEnvironment.js</a></li></ul></div>
      </div>
    
    </aside>
  
      <section class="section">
        
  <div class="entity-header">
    <h1>roomEnvironment.js</h1>
    <p class="subtitle">Module</p>
  </div>

      </section>
      
    <section class="section">
      <h2>Educational notes</h2>
      <p>Room Environment Manager</p>
<p>Manages room state including temperature, pressure, and air composition.</p>
<p>Integrates with AC unit and air handler systems.</p>
    </section>
  
      <section class="section" id="source-file">
        <h2>Source file</h2>
        <p><code>src\utils\roomEnvironment.js</code></p>
        <details>
          <summary>View source code</summary>
          <pre class="line-numbers"><code class="language-javascript">// NOTE: Read the header comments before editing. Reassess splitting into subcomponents when adding new items or behaviors.
/**
 * Room Environment Manager
 * 
 * Manages room state including temperature, pressure, and air composition.
 * Integrates with AC unit and air handler systems.
 */

import { applyAcControl, createPidState } from &#39;./acUnitHandler&#39;
import { applyScrubber, checkCompositionAlerts, EARTH_ATMOSPHERE } from &#39;./airHandlerScrubber&#39;
import { calculatePressure } from &#39;./physics/index.js&#39;

/**
 * Convert Unicode subscript digits to ASCII
 * Atmosphere composition uses ASCII formulas (H2O, C2H5OH)
 * but substance files use Unicode subscripts (H‚ÇÇO, C‚ÇÇH‚ÇÖOH)
 * 
 * @param {string} formula - Chemical formula with possible Unicode subscripts
 * @returns {string} Formula with ASCII digits
 */
export function normalizeFormula(formula) {
  if (!formula) return formula
  
  // Unicode subscript digits: ‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ
  const subscriptMap = {
    &#39;‚ÇÄ&#39;: &#39;0&#39;, &#39;‚ÇÅ&#39;: &#39;1&#39;, &#39;‚ÇÇ&#39;: &#39;2&#39;, &#39;‚ÇÉ&#39;: &#39;3&#39;, &#39;‚ÇÑ&#39;: &#39;4&#39;,
    &#39;‚ÇÖ&#39;: &#39;5&#39;, &#39;‚ÇÜ&#39;: &#39;6&#39;, &#39;‚Çá&#39;: &#39;7&#39;, &#39;‚Çà&#39;: &#39;8&#39;, &#39;‚Çâ&#39;: &#39;9&#39;
  }
  
  return formula.replace(/[‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ]/g, char =&gt; subscriptMap[char] || char)
}

/**
 * Get the atmosphere key for a substance
 * Uses the chemical formula from fluidProps, normalized to ASCII
 * Falls back to hardcoded mapping for solutions and edge cases
 * 
 * @param {string} substanceId - Substance ID from catalog
 * @param {object} fluidProps - Loaded fluid properties (optional, for formula lookup)
 * @returns {string} Atmosphere key for room composition tracking
 */
export function getAtmosphereKey(substanceId, fluidProps = null) {
  // If we have fluid props with a chemical formula, use it (normalized to ASCII)
  if (fluidProps?.chemicalFormula) {
    return normalizeFormula(fluidProps.chemicalFormula)
  }
  
  // Fallback mapping for solutions and edge cases
  // Solutions release their solvent&#39;s vapor
  const SOLUTION_SOLVENT_MAP = {
    &#39;saltwater-3pct&#39;: &#39;H2O&#39;,
    &#39;saltwater-10pct&#39;: &#39;H2O&#39;,
    &#39;saltwater-26pct&#39;: &#39;H2O&#39;,
  }
  
  return SOLUTION_SOLVENT_MAP[substanceId] || substanceId
}

/**
 * Calculate initial room pressure based on pressureMode and altitude
 * @param {object} roomConfig - Room config from room.json
 * @param {number} altitude - Altitude in meters
 * @returns {number} Pressure in Pa
 */
function getInitialPressure(roomConfig, altitude) {
  const pressureMode = roomConfig?.pressureMode || &#39;location&#39;
  
  switch (pressureMode) {
    case &#39;sealevel&#39;:
      return 101325
    case &#39;custom&#39;:
      return roomConfig?.room?.initialPressurePa || 101325
    case &#39;location&#39;:
    default:
      // Use ISA model to calculate pressure from altitude
      return calculatePressure(altitude || 0)
  }
}

/**
 * Create initial room state from room.json config
 * @param {object} roomConfig - Room config from room.json
 * @param {number} altitude - Altitude in meters (for pressureMode &#39;location&#39;)
 * @returns {object} Initial room state
 */
export function createRoomState(roomConfig, altitude = 0) {
  const room = roomConfig?.room || {}
  const atmosphere = roomConfig?.atmosphere || EARTH_ATMOSPHERE
  const initialPressure = getInitialPressure(roomConfig, altitude)
  
  return {
    // Physical properties
    volumeM3: room.volumeM3 || 30,
    heatCapacityJPerC: room.heatCapacityJPerC || 36000,
    leakRatePaPerSecond: room.leakRatePaPerSecond || 10,
    
    // Current state
    temperature: room.initialTempC || 20,
    pressure: initialPressure,
    composition: { ...atmosphere },
    
    // AC state
    acEnabled: false,  // AC on/off switch (default OFF, user must enable)
    acSetpoint: room.initialTempC || 20,
    acPidState: createPidState(),
    acHeatOutput: 0,
    
    // Air handler state
    airHandlerMode: roomConfig?.defaults?.airHandlerMode || &#39;off&#39;,
    scrubberActivity: 0,  // 0-1 activity level from PID
    targetComposition: { ...atmosphere },  // Original atmosphere to restore to
    
    // Logging
    heatLog: [],
    compositionLog: [],
    alerts: [],
    
    // Energy tracking for scorecard
    energyTotals: {
      acHeatingJoules: 0,
      acCoolingJoules: 0,
      airHandlerJoules: 0,  // Based on flow rate and time
      burnerWasteJoules: 0
    },
    
    // Initial state snapshot for before/after comparison
    initialComposition: { ...atmosphere },
    initialTemperature: room.initialTempC || 20,
    initialPressure: initialPressure,
    
    // Exposure tracking for health consequences
    exposureEvents: [],  // { substanceId, concentration, durationSec, severity }
    
    // Timestamps
    startTime: Date.now(),
    lastUpdate: Date.now()
  }
}

/**
 * Add vapor from boiling substance to room composition
 * @param {object} roomState - Current room state
 * @param {string} substanceId - Substance being vaporized (e.g., &#39;water&#39;, &#39;ethanol&#39;)
 * @param {number} massEvaporatedKg - Mass evaporated this timestep (kg)
 * @param {number} molarMassKgPerMol - Molar mass of substance (kg/mol)
 * @param {string} chemicalFormula - Chemical formula (e.g., &#39;H‚ÇÇO&#39;) for atmosphere key lookup
 * @returns {object} Updated room state
 */
export function addVaporToRoom(roomState, substanceId, massEvaporatedKg, molarMassKgPerMol, chemicalFormula = null) {
  if (massEvaporatedKg &lt;= 0) return roomState

  // Map substance ID to atmosphere key using formula if available
  const atmosphereKey = getAtmosphereKey(substanceId, chemicalFormula ? { chemicalFormula } : null)

  // Calculate moles added
  const molesAdded = massEvaporatedKg / molarMassKgPerMol
  
  // Approximate total moles in room (ideal gas at STP: ~1200 mol for 30m¬≥)
  const R = 8.314  // J/(mol¬∑K)
  const tempK = roomState.temperature + 273.15
  const totalMolesApprox = (roomState.pressure * roomState.volumeM3) / (R * tempK)
  
  // Update composition using atmosphere key (e.g., &#39;H2O&#39; not &#39;water&#39;)
  const newComposition = { ...roomState.composition }
  const currentFraction = newComposition[atmosphereKey] || 0
  const addedFraction = molesAdded / (totalMolesApprox + molesAdded)
  
  // Normalize: reduce all existing fractions slightly, add new substance
  const scaleFactor = totalMolesApprox / (totalMolesApprox + molesAdded)
  for (const species of Object.keys(newComposition)) {
    newComposition[species] *= scaleFactor
  }
  newComposition[atmosphereKey] = (currentFraction * scaleFactor) + addedFraction
  
  // Pressure increase from added moles (closed system)
  const newTotalMoles = totalMolesApprox + molesAdded
  const newPressure = (newTotalMoles * R * tempK) / roomState.volumeM3
  
  return {
    ...roomState,
    composition: newComposition,
    pressure: newPressure
  }
}

/**
 * Toxic exposure thresholds and health consequences
 * Based on OSHA PEL (Permissible Exposure Limits) and IDLH (Immediately Dangerous to Life or Health)
 */
const TOXIC_THRESHOLDS = {
  NH3: {  // Ammonia
    name: &#39;Ammonia&#39;,
    safePPM: 25,       // OSHA PEL: 25 ppm
    warningPPM: 50,    // Noticeable irritation
    dangerPPM: 300,    // IDLH: 300 ppm
    consequences: {
      warning: &#39;Eye and respiratory irritation. Headache developing.&#39;,
      danger: &#39;Severe respiratory distress! Immediate evacuation required.&#39;,
      critical: &#39;Life-threatening exposure. Pulmonary edema risk.&#39;
    }
  },
  acetone: {
    name: &#39;Acetone&#39;,
    safePPM: 250,      // OSHA PEL: 250 ppm
    warningPPM: 500,
    dangerPPM: 2500,   // IDLH: 2500 ppm
    consequences: {
      warning: &#39;Mild dizziness and headache. Eyes watering.&#39;,
      danger: &#39;Significant CNS depression. Confusion and weakness.&#39;,
      critical: &#39;Loss of consciousness possible. Evacuate immediately.&#39;
    }
  },
  C2H5OH: {  // Ethanol
    name: &#39;Ethanol&#39;,
    safePPM: 1000,     // OSHA PEL: 1000 ppm
    warningPPM: 2000,
    dangerPPM: 3300,   // IDLH: 3300 ppm
    consequences: {
      warning: &#39;Feeling lightheaded. Sweet smell noticeable.&#39;,
      danger: &#39;Intoxication symptoms. Impaired judgment.&#39;,
      critical: &#39;Severe intoxication. Risk of unconsciousness.&#39;
    }
  },
  CH4: {  // Methane (asphyxiant, not directly toxic)
    name: &#39;Methane&#39;,
    safePPM: 10000,    // 1% - starts displacing oxygen
    warningPPM: 50000, // 5% - LEL (Lower Explosive Limit)
    dangerPPM: 150000, // 15% - UEL (Upper Explosive Limit)
    consequences: {
      warning: &#39;Oxygen being displaced. Ventilate immediately.&#39;,
      danger: &#39;EXPLOSIVE ATMOSPHERE! No sparks or flames!&#39;,
      critical: &#39;Asphyxiation risk. Explosive mixture present.&#39;
    }
  }
}

/**
 * Track toxic exposure based on current room composition
 * @param {object} roomState - Current room state
 * @param {object} airHandler - Air handler config (for filter effectiveness)
 * @param {number} deltaTime - Time step (seconds)
 * @returns {object} Updated room state with exposure events
 */
function trackExposure(roomState, airHandler, deltaTime) {
  const exposureEvents = [...(roomState.exposureEvents || [])]
  const composition = roomState.composition
  
  // Check each toxic substance
  for (const [substanceId, thresholds] of Object.entries(TOXIC_THRESHOLDS)) {
    const fraction = composition[substanceId] || 0
    const ppm = fraction * 1000000  // Convert fraction to ppm
    
    if (ppm &gt; thresholds.safePPM) {
      // Determine severity
      let severity = &#39;warning&#39;
      let consequence = thresholds.consequences.warning
      if (ppm &gt; thresholds.dangerPPM) {
        severity = &#39;critical&#39;
        consequence = thresholds.consequences.critical
      } else if (ppm &gt; thresholds.warningPPM) {
        severity = &#39;danger&#39;
        consequence = thresholds.consequences.danger
      }
      
      // Check if filter would protect (pro air handler with activated carbon)
      const filterEfficiency = airHandler?.filtrationEfficiency?.[substanceId] || 0
      const isProtected = filterEfficiency &gt; 0.5 &amp;&amp; roomState.airHandlerMode !== &#39;off&#39;
      
      // Add or update exposure event
      const existingIdx = exposureEvents.findIndex(e =&gt; e.substanceId === substanceId)
      if (existingIdx &gt;= 0) {
        exposureEvents[existingIdx].durationSec += deltaTime
        exposureEvents[existingIdx].peakPPM = Math.max(exposureEvents[existingIdx].peakPPM, ppm)
        exposureEvents[existingIdx].severity = severity
        exposureEvents[existingIdx].consequence = consequence
        exposureEvents[existingIdx].isProtected = isProtected
      } else {
        exposureEvents.push({
          substanceId,
          name: thresholds.name,
          startTime: Date.now() - roomState.startTime,
          durationSec: deltaTime,
          peakPPM: ppm,
          severity,
          consequence,
          isProtected
        })
      }
    }
  }
  
  return {
    ...roomState,
    exposureEvents
  }
}

/**
 * Apply heat to room from external source (burner waste heat, etc.)
 * @param {object} roomState - Current room state
 * @param {number} heatWatts - Heat input (positive = heating, negative = cooling)
 * @param {number} deltaTime - Time step (seconds)
 * @param {string} source - Heat source identifier for logging
 * @returns {object} Updated room state
 */
export function applyHeatToRoom(roomState, heatWatts, deltaTime, source = &#39;unknown&#39;) {
  if (heatWatts === 0) return roomState

  const heatJoules = heatWatts * deltaTime
  const tempChange = heatJoules / roomState.heatCapacityJPerC
  
  // Log heat event
  const newHeatLog = [...roomState.heatLog]
  if (newHeatLog.length === 0 || newHeatLog[newHeatLog.length - 1].source !== source) {
    newHeatLog.push({
      timestamp: Date.now() - roomState.startTime,
      source,
      watts: heatWatts
    })
  }
  
  // Keep log from growing too large (keep last 1000 entries)
  if (newHeatLog.length &gt; 1000) {
    newHeatLog.shift()
  }
  
  return {
    ...roomState,
    temperature: roomState.temperature + tempChange,
    heatLog: newHeatLog
  }
}

/**
 * Calculate combined system airflow (AC + Air Handler)
 * AC has its own base CFM. Air handler augments when connected and running.
 * @param {object} acUnit - AC unit config
 * @param {object} airHandler - Air handler config  
 * @param {string} airHandlerMode - Current air handler mode
 * @returns {object} { totalCFM, totalM3PerHour, acContribution, ahContribution }
 */
function calculateCombinedAirflow(acUnit, airHandler, airHandlerMode) {
  // AC base airflow (always running when AC is on)
  const acCFM = acUnit?.airflowCharacteristics?.baseCFM || 150
  const acM3h = acUnit?.airflowCharacteristics?.baseM3PerHour || 255
  
  // Air handler augments when running
  let ahCFM = 0
  let ahM3h = 0
  if (airHandler &amp;&amp; airHandlerMode !== &#39;off&#39;) {
    const flowPercent = airHandler.operatingModes?.[airHandlerMode]?.flowPercent || 0
    ahCFM = (airHandler.flowCharacteristics?.maxFlowRateCFM || 0) * (flowPercent / 100)
    ahM3h = (airHandler.flowCharacteristics?.maxFlowRateM3PerHour || 0) * (flowPercent / 100)
  }
  
  return {
    totalCFM: acCFM + ahCFM,
    totalM3PerHour: acM3h + ahM3h,
    acContribution: acCFM,
    ahContribution: ahCFM
  }
}

/**
 * Simulate one timestep of room environment
 * @param {object} roomState - Current room state
 * @param {object} acUnit - AC unit config (from JSON)
 * @param {object} airHandler - Air handler config (from JSON)
 * @param {number} deltaTime - Time step (seconds)
 * @param {object} options - { externalHeat, vaporInput }
 * @returns {object} Updated room state
 */
export function simulateRoomStep(roomState, acUnit, airHandler, deltaTime, options = {}) {
  let state = { ...roomState }
  
  // Calculate combined airflow for this timestep
  const airflow = calculateCombinedAirflow(acUnit, airHandler, state.airHandlerMode)
  
  // 1. Apply external heat (burner waste heat radiating into room)
  if (options.externalHeat) {
    const wasteHeatFraction = 0.1  // 10% of burner heat goes to room
    const roomHeat = options.externalHeat * wasteHeatFraction
    state = applyHeatToRoom(state, roomHeat, deltaTime, &#39;burner_waste&#39;)
  }
  
  // 2. Apply AC control (effectiveness scales with airflow)
  // Skip if AC is disabled
  let acResult = { newTemp: state.temperature, heatOutput: 0, updatedPidState: state.acPidState }
  if (state.acEnabled &amp;&amp; acUnit) {
    // More airflow = faster air exchange = AC works better
    const airflowEffectiveness = Math.min(1.5, airflow.totalCFM / 150)  // 150 CFM = baseline
    acResult = applyAcControl(
      state.temperature,
      state.acSetpoint,
      acUnit,
      state.acPidState,
      deltaTime * airflowEffectiveness,  // Effective time step scaled by airflow
      state.volumeM3
    )
  }
  
  // Track AC energy usage
  const acJoules = Math.abs(acResult.heatOutput) * deltaTime
  const updatedEnergyTotals = { ...state.energyTotals }
  if (acResult.heatOutput &gt; 0) {
    updatedEnergyTotals.acHeatingJoules += acJoules
  } else if (acResult.heatOutput &lt; 0) {
    updatedEnergyTotals.acCoolingJoules += acJoules
  }
  
  state = {
    ...state,
    temperature: acResult.newTemp,
    acPidState: acResult.updatedPidState,
    acHeatOutput: acResult.heatOutput,
    currentAirflow: airflow,
    energyTotals: updatedEnergyTotals
  }
  
  // Log AC heat
  if (Math.abs(acResult.heatOutput) &gt; 10) {
    state = applyHeatToRoom(state, 0, deltaTime, acResult.heatOutput &gt; 0 ? &#39;ac_heating&#39; : &#39;ac_cooling&#39;)
  }
  
  // 3. Apply vapor from boiling (if provided)
  if (options.vaporInput) {
    const { substanceId, massKg, molarMass, chemicalFormula } = options.vaporInput
    state = addVaporToRoom(state, substanceId, massKg, molarMass, chemicalFormula)
  }
  
  // 4. Apply air handler/scrubber (uses automatic PID-like control)
  const scrubberResult = applyScrubber(
    state.composition,
    airHandler,
    state.volumeM3,
    deltaTime,
    state.airHandlerMode,
    state.targetComposition  // Original atmosphere to restore to
  )
  
  // Track air handler energy (based on CFM and typical fan power ~0.5W per CFM)
  const ahPowerWatts = airflow.ahContribution * 0.5
  state = {
    ...state,
    composition: scrubberResult.newComposition,
    scrubberActivity: scrubberResult.activity || 0,
    energyTotals: {
      ...state.energyTotals,
      airHandlerJoules: state.energyTotals.airHandlerJoules + (ahPowerWatts * deltaTime)
    }
  }
  
  // 5. Check for toxic exposure and track consequences
  state = trackExposure(state, airHandler, deltaTime)
  
  // 6. Room pressure leak (slow return toward ambient)
  const ambientPressure = 101325  // Hardcoded sea level - See TODO.md #3 (room phase 2)
  const pressureDiff = state.pressure - ambientPressure
  const leakRate = state.leakRatePaPerSecond || 10
  const pressureChange = Math.sign(pressureDiff) * Math.min(Math.abs(pressureDiff), leakRate * deltaTime)
  state = {
    ...state,
    pressure: state.pressure - pressureChange
  }
  
  // 7. Check for safety alerts
  const newAlerts = checkCompositionAlerts(state.composition)
  
  // 8. Log composition periodically (every 10 seconds of sim time)
  const simTime = Date.now() - state.startTime
  const lastLogTime = state.compositionLog.length &gt; 0 
    ? state.compositionLog[state.compositionLog.length - 1].timestamp 
    : 0
  if (simTime - lastLogTime &gt; 10000) {
    state = {
      ...state,
      compositionLog: [
        ...state.compositionLog.slice(-99),  // Keep last 100 entries
        { timestamp: simTime, composition: { ...state.composition } }
      ]
    }
  }
  
  state = {
    ...state,
    alerts: newAlerts,
    lastUpdate: Date.now()
  }
  
  return state
}

/**
 * Get room state summary for UI display
 * @param {object} roomState - Current room state
 * @returns {object} Summary object for display
 */
export function getRoomSummary(roomState) {
  return {
    temperature: Math.round(roomState.temperature * 10) / 10,
    pressure: Math.round(roomState.pressure),
    pressureKPa: Math.round(roomState.pressure / 100) / 10,
    humidity: Math.round((roomState.composition.H2O || 0) * 100 * 10) / 10,
    o2Percent: Math.round((roomState.composition.O2 || 0) * 100 * 10) / 10,
    co2Percent: Math.round((roomState.composition.CO2 || 0) * 100 * 100) / 100,
    alerts: roomState.alerts,
    acStatus: roomState.acHeatOutput,
    acEnabled: roomState.acEnabled,
    acSetpoint: roomState.acSetpoint,
    airHandlerMode: roomState.airHandlerMode,
    scrubberActivity: roomState.scrubberActivity || 0
  }
}
</code></pre>
        </details>
      </section>
    
        </article>
      </main>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
  <script>
    // Lazy-load Kekule only when molecule viewer is expanded (saves bandwidth on low-end devices)
    (() => {
      let smilesDrawerLoaded = false
      let smilesDrawerLoading = false
      
      // Convert explicit SMILES like [CH3][CH](OH)[CH3] to standard like CC(O)C
      const explicitToStandard = (smiles) => {
        return smiles
          // Common organic groups - order matters (longer patterns first)
          .replace(/\[CH3\]/g, 'C')
          .replace(/\[CH2\]/g, 'C')
          .replace(/\[CH\]/g, 'C')
          .replace(/\[OH\]/g, 'O')
          .replace(/\[NH2\]/g, 'N')
          .replace(/\[NH\]/g, 'N')
          .replace(/\[SH\]/g, 'S')
          // Single atoms in brackets (keep aromatic lowercase)
          .replace(/\[C\]/g, 'C')
          .replace(/\[N\]/g, 'N')
          .replace(/\[O\]/g, 'O')
          .replace(/\[S\]/g, 'S')
          .replace(/\[P\]/g, 'P')
          .replace(/\[F\]/g, 'F')
          .replace(/\[Cl\]/g, 'Cl')
          .replace(/\[Br\]/g, 'Br')
          .replace(/\[I\]/g, 'I')
          // Bare atoms in branches - H is implicit in standard SMILES
          .replace(/\(OH\)/g, '(O)')
          .replace(/\(NH2\)/g, '(N)')
          .replace(/\(NH\)/g, '(N)')
          .replace(/\(SH\)/g, '(S)')
      }
      
      const loadSmilesDrawer = async () => {
        if (smilesDrawerLoaded) return
        if (smilesDrawerLoading) {
          return new Promise(resolve => {
            const check = setInterval(() => {
              if (smilesDrawerLoaded) { clearInterval(check); resolve() }
            }, 50)
          })
        }
        smilesDrawerLoading = true
        
        // Load SmilesDrawer from CDN (much simpler than Kekule)
        await new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = 'https://unpkg.com/smiles-drawer@2.1.7/dist/smiles-drawer.min.js'
          script.onload = resolve
          script.onerror = reject
          document.body.appendChild(script)
        })
        
        smilesDrawerLoaded = true
        smilesDrawerLoading = false
      }
      
      const initMolecule = async (node) => {
        if (node.dataset.initialized) return
        node.dataset.initialized = 'true'
        
        const rawSmiles = node.getAttribute('data-smiles')
        if (!rawSmiles) return
        
        // Convert explicit format to standard if needed
        const smiles = explicitToStandard(rawSmiles)
        
        try {
          await loadSmilesDrawer()
          
          const drawer = new SmilesDrawer.SvgDrawer({ 
            width: 300, 
            height: 200,
            explicitHydrogens: true,
            terminalCarbons: true,
            compactDrawing: false
          })
          
          console.log('Parsing SMILES:', rawSmiles, '->', smiles)
          SmilesDrawer.parse(smiles, (tree) => {
            console.log('Parse success, tree:', tree)
            const svgElement = drawer.draw(tree, null, 'light')
            console.log('SVG element:', svgElement)
            node.innerHTML = ''
            node.appendChild(svgElement)
          }, (err) => {
            console.error('SMILES parse error for "' + smiles + '":', err)
            node.innerHTML = '<code>' + rawSmiles + '</code>'
          })
        } catch (err) {
          console.error('SmilesDrawer load error:', err)
          node.innerHTML = '<code>' + smiles + '</code>'
        }
      }
      
      // Use IntersectionObserver for lazy loading when scrolled into view
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initMolecule(entry.target)
            observer.unobserve(entry.target)
          }
        })
      }, { rootMargin: '100px' })
      
      // Also handle <details> expansion for molecules inside collapsed sections
      document.addEventListener('toggle', (e) => {
        if (e.target.tagName === 'DETAILS' && e.target.open) {
          const molecules = e.target.querySelectorAll('[data-smiles]:not([data-initialized])')
          molecules.forEach(node => initMolecule(node))
        }
      }, true)
      
      // Observe all molecule nodes
      const init = () => {
        const nodes = document.querySelectorAll('[data-smiles]')
        nodes.forEach(node => observer.observe(node))
      }
      
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init)
      } else {
        init()
      }
    })()
  </script>
</body>
</html>