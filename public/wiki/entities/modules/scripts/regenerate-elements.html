<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>regenerate-elements.js - Boiling Water Wiki</title>
  <link rel="stylesheet" href="/wiki/assets/styles.css" />
  <!-- Kekule CSS loaded lazily when molecule viewer is needed -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />
</head>
<body>
  <div class="wiki-layout">
    <div class="wiki-main">
      <header class="wiki-topbar">
        <details class="wiki-menu" aria-label="Menu">
          <summary>‚ò∞ Menu</summary>
          <nav class="wiki-menu-links">
            <div class="menu-section">
              <div class="menu-heading">Main</div>
              <a href="/wiki/index.html">üìö Main page</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Science</div>
              <a href="/wiki/entities/elements/index.html">‚öõÔ∏è Elements</a>
              <a href="/wiki/entities/compounds/index.html">üß™ Compounds</a>
              <a href="/wiki/entities/solutions/index.html">üíß Solutions</a>
              <a href="/wiki/entities/phases/index.html">‚ùÑÔ∏è Phases</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Game Structure</div>
              <a href="/wiki/entities/levels/index.html">üìä Levels</a>
              <a href="/wiki/entities/experiments/index.html">üî¨ Experiments</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Code Reference</div>
              <a href="/wiki/entities/formulas/index.html">üìê Formulas</a>
              <a href="/wiki/entities/processes/index.html">‚öôÔ∏è Processes</a>
              <a href="/wiki/entities/modules/index.html">üì¶ Modules</a>
              <a href="/wiki/entities/symbols/index.html">üî£ Symbols</a>
              <a href="/wiki/entities/public/index.html">üìÅ Public Files</a>
              <a href="/wiki/entities/assets/index.html">üñºÔ∏è Assets</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Repository</div>
              <a href="/wiki/entities/docs/index.html">üìñ Docs</a>
              <a href="/wiki/entities/scripts/index.html">üß∞ Scripts</a>
              <a href="/wiki/entities/styles/index.html">üé® Styles</a>
              <a href="/wiki/entities/root-files/index.html">üóÇÔ∏è Root Files</a>
              <a href="/wiki/entities/reports/changes-since-last-commit.html">üß≠ Changes</a>
            </div>
            <div class="wiki-menu-divider"></div>
            <a href="/">‚¨ÖÔ∏è Back to Game</a>
          </nav>
        </details>
        
        <nav class="breadcrumbs" aria-label="Breadcrumb">
          <a href="/wiki/../../../index.html">Main</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../index.html">Modules</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../scripts/index.html">scripts</a> <span class="breadcrumb-sep">‚Ä∫</span> <span>regenerate-elements.js</span>
        </nav>
        <div class="wiki-topbar-title">regenerate-elements.js</div>
      </header>
      <main class="wiki-content">
        
        <article class="wiki-article">
          
      
    <aside class="infobox">
      <div class="infobox-title">regenerate-elements.js</div>
      
      <div class="infobox-row">
        <div class="infobox-label">Type</div>
        <div class="infobox-value">Module</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">File type</div>
        <div class="infobox-value">js</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">Imports</div>
        <div class="infobox-value"><span class="external-import">fs</span>, <span class="external-import">path</span>, <span class="external-import">url</span></div>
      </div>
    
    </aside>
  
      <section class="section">
        
  <div class="entity-header">
    <h1>regenerate-elements.js</h1>
    <p class="subtitle">Module</p>
  </div>

      </section>
      
    <section class="section">
      <h2>Educational notes</h2>
      <p>Smart Element Data Regenerator</p>
<p>Intelligently updates element JSON files from PubChem/NIST sources.</p>
<p>Only fetches and updates data when necessary.</p>
<p>Usage:</p>
<p>node regenerate-elements.js                    # Check existing, make no changes</p>
<p>node regenerate-elements.js --update           # Update with new data fields (e.g., phase data)</p>
<p>node regenerate-elements.js --recreate         # EMERGENCY ONLY: Full rebuild from scratch</p>
<p>How it works:</p>
<p>1. Scans existing element JSONs to determine current schema</p>
<p>2. If --update: Fetches ONLY new fields from PubChem</p>
<p>3. If --recreate: Rebuilds all 118 elements from scratch (commented out, use carefully)</p>
<p>4. Reports changes made and files updated</p>
    </section>
  
      <section class="section" id="source-file">
        <h2>Source file</h2>
        <p><code>scripts\regenerate-elements.js</code></p>
        <details>
          <summary>View source code</summary>
          <pre class="line-numbers"><code class="language-javascript">#!/usr/bin/env node
/**
 * Smart Element Data Regenerator
 * 
 * Intelligently updates element JSON files from PubChem/NIST sources.
 * Only fetches and updates data when necessary.
 * 
 * Usage:
 *   node regenerate-elements.js                    # Check existing, make no changes
 *   node regenerate-elements.js --update           # Update with new data fields (e.g., phase data)
 *   node regenerate-elements.js --recreate         # EMERGENCY ONLY: Full rebuild from scratch
 * 
 * How it works:
 * 1. Scans existing element JSONs to determine current schema
 * 2. If --update: Fetches ONLY new fields from PubChem
 * 3. If --recreate: Rebuilds all 118 elements from scratch (commented out, use carefully)
 * 4. Reports changes made and files updated
 */

import fs from &#39;fs&#39;;
import path from &#39;path&#39;;
import { fileURLToPath } from &#39;url&#39;;

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ELEMENTS_DIR = path.join(__dirname, &#39;../src/data/substances/periodic-table&#39;);
const TEMP_OUTPUT_DIR = path.join(ELEMENTS_DIR, &#39;_regen-temp&#39;);
const ELEMENTS_GAMEPLAY_DIR = path.join(__dirname, &#39;../src/data/substances/elements&#39;);

// Parse command-line arguments
const args = process.argv.slice(2);
const UPDATE_MODE = args.includes(&#39;--update&#39;);
const RECREATE_MODE = args.includes(&#39;--recreate&#39;);
const EXPORT_RAW_MODE = args.includes(&#39;--export-raw&#39;);
const LIMIT_ARG = args.find(arg =&gt; arg.startsWith(&#39;--limit=&#39;));
const EXPORT_LIMIT = LIMIT_ARG ? Number.parseInt(LIMIT_ARG.split(&#39;=&#39;)[1], 10) : null;

// ============================================================================
// SCHEMA DEFINITIONS
// ============================================================================

/**
 * Current schema - what we have in existing files
 */
const CURRENT_SCHEMA = {
  atomicNumber: &#39;number&#39;,
  symbol: &#39;string&#39;,
  name: &#39;string&#39;,
  elementCategory: &#39;string&#39;,
  chemicalBlock: &#39;string&#39;,
  valenceElectrons: &#39;number&#39;,
  oxidationStates: &#39;array&#39;,
  standardUsed: &#39;string&#39;,
  nist: &#39;object&#39;,
  iupac: &#39;object&#39;,
  physicalProperties: &#39;object&#39;,
  lastUpdated: &#39;string&#39;,
  educationalNotes: &#39;string&#39;,
  diffusion: &#39;object&#39;
};

/**
 * New fields to add when --update is used
 * This is what we want to ADD to existing files
 */
const NEW_FIELDS_UPDATE = {
  physicalProperties: {
    phases: {
      gas: { description: &#39;Gas phase properties&#39; },
      liquid: { description: &#39;Liquid phase properties&#39; },
      solid: { description: &#39;Solid phase properties&#39; }
    }
  }
};

/**
 * Full schema if recreating from scratch (COMMENTED OUT - dangerous)
 * Only use if files are corrupted or lost
 */
const FULL_SCHEMA_FROM_SCRATCH = {
  // Include all fields for fresh generation
  // ... would include everything ...
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Detect what fields are missing from an existing element JSON
 */
function detectMissingFields(existingJson) {
  const missing = [];
  
  // Check for phase data in physicalProperties
  if (existingJson.physicalProperties &amp;&amp; !existingJson.physicalProperties.phases) {
    missing.push(&#39;physicalProperties.phases&#39;);
  }
  
  // Add more detection logic here as needed
  
  return missing;
}

/**
 * Load all existing element files and analyze schema
 */
function analyzeExistingElements() {
  if (!fs.existsSync(ELEMENTS_DIR)) {
    console.log(&#39;‚ùå Elements directory not found. Run with --recreate to build from scratch.&#39;);
    return null;
  }

  let files = fs.readdirSync(ELEMENTS_DIR).filter(f =&gt; f.endsWith(&#39;.json&#39;));
  if (Number.isFinite(EXPORT_LIMIT)) {
    files = files.slice(0, EXPORT_LIMIT);
  }
  
  if (files.length === 0) {
    console.log(&#39;‚ùå No element files found. Run with --recreate to build from scratch.&#39;);
    return null;
  }

  console.log(`üìä Found ${files.length} existing element files`);
  
  // Analyze first file to detect schema
  const samplePath = path.join(ELEMENTS_DIR, files[0]);
  const sample = JSON.parse(fs.readFileSync(samplePath, &#39;utf8&#39;));
  
  console.log(`üìã Sample element schema: ${Object.keys(sample).join(&#39;, &#39;)}`);
  
  // Check all files for missing fields
  const filesNeedingUpdate = [];
  
  for (const file of files) {
    const filePath = path.join(ELEMENTS_DIR, file);
    const data = JSON.parse(fs.readFileSync(filePath, &#39;utf8&#39;));
    const missing = detectMissingFields(data);
    
    if (missing.length &gt; 0) {
      filesNeedingUpdate.push({ file, missing });
    }
  }
  
  return {
    totalFiles: files.length,
    filesNeedingUpdate,
    sampleSchema: Object.keys(sample)
  };
}

function ensureTempOutputDir() {
  if (!fs.existsSync(TEMP_OUTPUT_DIR)) {
    fs.mkdirSync(TEMP_OUTPUT_DIR, { recursive: true });
  }
}

/**
 * NOTE: PubChem HTML structure requires proper parsing to extract ALL sources
 * 
 * Expected sources for each property:
 * - Atomic Weight: NIST (with uncertainty range), IUPAC, CAS
 * - Electronegativity: Pauling scale, Allred-Rochow, Sanderson
 * - Atomic Radius: Covalent, Van der Waals, Metallic
 * - Ionization Energy: First IE, subsequent IEs per shell
 * 
 * Current implementation does basic pattern matching.
 * For production, consider:
 * 1. Puppeteer/Playwright for JavaScript-rendered content
 * 2. PubChem&#39;s non-public XML API if available
 * 3. Manual JSON catalog of authoritative values with full citations
 */

/**
 * Fetch element data from PubChem
 * Extracts ALL sources and values for each property
 */
async function fetchPubChemElementData(atomicNumber, symbol) {
  try {
    const url = `https://pubchem.ncbi.nlm.nih.gov/rest/pug_view/data/element/${atomicNumber}/JSON`;
    const response = await fetch(url);
    
    if (!response.ok) {
      console.warn(`    ‚ö†Ô∏è  Could not fetch PubChem data for ${symbol} (HTTP ${response.status})`);
      return null;
    }

    const data = await response.json();
    const { allProperties, sourcesByName, referenceIndex } = extractAllPropertiesFromPubChemJson(data);
    const education = extractEducationalNotesFromPubChemJson(data);
    const propertyNotes = extractPropertyNotesFromPubChemProperties(allProperties);

    // Keep a small set of convenience fields for quick comparisons
    const parsed = {
      symbol,
      atomicNumber,
      atomicMass: pickPropertyList(allProperties, [&#39;Atomic Weight&#39;, &#39;Relative Atomic Mass&#39;, &#39;Standard Atomic Weight&#39;]),
      electronegativity: pickPropertyList(allProperties, [&#39;Electronegativity&#39;, &#39;Electronegativity (Pauling)&#39;]),
      ionizationEnergy: pickPropertyList(allProperties, [&#39;Ionization Energy&#39;, &#39;First Ionization Energy&#39;]),
      atomicRadius: pickPropertyList(allProperties, [&#39;Atomic Radius&#39;, &#39;Atomic Radius (Covalent)&#39;, &#39;Atomic Radius (Van der Waals)&#39;]),
      electronAffinity: pickPropertyList(allProperties, [&#39;Electron Affinity&#39;]),
      meltingPoint: pickPropertyList(allProperties, [&#39;Melting Point&#39;]),
      boilingPoint: pickPropertyList(allProperties, [&#39;Boiling Point&#39;]),
      density: pickPropertyList(allProperties, [&#39;Density&#39;]),
      thermalConductivity: pickPropertyList(allProperties, [&#39;Thermal Conductivity&#39;]),
      properties: allProperties,
      sourcesByName,
      references: referenceIndex,
      source: &#39;PubChem PUG-View (NIH - multiple authoritative sources)&#39;,
      education: {
        ...education,
        propertyNotes
      }
    };
    
    return parsed;
  } catch (error) {
    console.warn(`    ‚ö†Ô∏è  Error fetching ${symbol}: ${error.message}`);
    return null;
  }
}

/**
 * Extract property values and sources from PubChem HTML tables
 * Returns array of { value, source, note } objects
 */
function extractPropertyFromTable(html, propertyPattern) {
  const results = [];
  
  // Match table rows containing the property
  // Format: &lt;tr&gt;...&lt;td&gt;Property Name&lt;/td&gt;...&lt;td&gt;123.45&lt;/td&gt;...&lt;td&gt;Source Info&lt;/td&gt;...&lt;/tr&gt;
  const rowPattern = new RegExp(`&lt;tr[^&gt;]*&gt;.*?${propertyPattern}.*?&lt;/tr&gt;`, &#39;gi&#39;);
  const tablePattern = /&lt;table[^&gt;]*&gt;[\s\S]*?&lt;\/table&gt;/gi;
  
  let tableMatch;
  while ((tableMatch = tablePattern.exec(html)) !== null) {
    const table = tableMatch[0];
    
    let rowMatch;
    const localRowPattern = new RegExp(`&lt;tr[^&gt;]*&gt;.*?${propertyPattern}.*?&lt;/tr&gt;`, &#39;gi&#39;);
    while ((rowMatch = localRowPattern.exec(table)) !== null) {
      const row = rowMatch[0];
      
      // Extract all &lt;td&gt; contents
      const tdPattern = /&lt;td[^&gt;]*&gt;(.*?)&lt;\/td&gt;/gi;
      const tds = [];
      let tdMatch;
      while ((tdMatch = tdPattern.exec(row)) !== null) {
        // Clean up HTML tags
        const text = tdMatch[1]
          .replace(/&lt;[^&gt;]*&gt;/g, &#39;&#39;)
          .replace(/&amp;nbsp;/g, &#39; &#39;)
          .replace(/&amp;amp;/g, &#39;&amp;&#39;)
          .trim();
        if (text) tds.push(text);
      }
      
      // Extract value and source from cells
      if (tds.length &gt;= 2) {
        // Usually: [Property, Value, Source/Notes]
        const value = tds[1]?.match(/[\d.¬±+\-]/g)?.join(&#39;&#39;) || tds[1];
        const source = tds[2] || tds.slice(2).join(&#39; &#39;) || &#39;Unknown&#39;;
        
        if (value &amp;&amp; !isNaN(parseFloat(value))) {
          results.push({
            value: parseFloat(value),
            rawValue: value,
            source: source.substring(0, 100), // Truncate long source strings
            note: tds.slice(3).join(&#39; &#39;)
          });
        }
      }
    }
  }
  
  // Deduplicate
  const unique = [];
  const seen = new Set();
  for (const result of results) {
    const key = result.value.toString();
    if (!seen.has(key)) {
      unique.push(result);
      seen.add(key);
    }
  }
  
  return unique.length &gt; 0 ? unique : null;
}

/**
 * Load phase state data for an element&#39;s pure form
 * Elements are stored as compounds with phase folders
 * For now, returns empty object (elements don&#39;t have compound entries yet)
 * This is a placeholder for future water/element state data
 */
function loadElementPhaseStates(elementSymbol) {
  const states = {
    solid: null,
    liquid: null,
    gas: null
  };
  
  // Elements don&#39;t have state.json files like compounds do
  // Phase properties are derived from PubChem properties (meltingPoint, boilingPoint, density, etc.)
  // This function serves as a placeholder for future structured state data
  
  return states;
}

/**
 * Build phase state summaries from element properties
 * Derives phase info from meltingPoint, boilingPoint, and phase-specific properties
 */
function buildPhaseDataFromProperties(props) {
  const phases = {};
  
  // Check if element has solid phase (has meltingPoint or melting point data)
  if (props.meltingPoint) {
    phases.solid = {
      phaseName: props.physicalDescription?.includes(&#39;Gas&#39;) ? null : &#39;solid&#39;,
      meltingPoint: props.meltingPoint,
      density: props.density &amp;&amp; !props.physicalDescription?.includes(&#39;Gas&#39;) ? props.density : null,
      specificHeat: null,
      thermalConductivity: props.thermalConductivity
    };
  }
  
  // Check if element has liquid phase (has boilingPoint and not pure gas)
  if (props.boilingPoint) {
    phases.liquid = {
      phaseName: &#39;liquid&#39;,
      boilingPoint: props.boilingPoint,
      meltingPoint: props.meltingPoint,
      density: props.density,
      specificHeat: null,
      thermalConductivity: props.thermalConductivity
    };
  }
  
  // All elements have gas phase at sufficient temperature
  phases.gas = {
    phaseName: &#39;gas&#39;,
    density: props.density &amp;&amp; props.physicalDescription?.includes(&#39;Gas&#39;) ? props.density : null,
    boilingPoint: props.boilingPoint,
    thermalConductivity: props.thermalConductivity
  };
  
  return phases;
}


function extractAllPropertiesFromPubChemJson(data) {
  const properties = [];
  const record = data?.Record;
  const referenceIndex = buildReferenceIndex(record?.Reference || []);

  const propertiesSection = (record?.Section || []).find(section =&gt; section.TOCHeading === &#39;Properties&#39;);
  const propertySections = propertiesSection?.Section || [];

  for (const section of propertySections) {
    const propertyName = section.TOCHeading;
    const infoList = section.Information || [];

    for (const info of infoList) {
      const rawValue = extractInfoValue(info);
      if (!rawValue) continue;

      const numeric = parseNumericValue(rawValue);
      const referenceNumber = info.ReferenceNumber;
      const reference = referenceIndex[referenceNumber] || null;
      const sourceName = reference?.SourceName || &#39;Unknown&#39;;
      const sourceUrl = reference?.URL || &#39;&#39;;

      properties.push({
        property: propertyName,
        value: Number.isFinite(numeric) ? numeric : rawValue,
        rawValue,
        source: sourceName,
        sourceUrl,
        licenseUrl: reference?.LicenseURL || &#39;&#39;,
        licenseNote: reference?.LicenseNote || &#39;&#39;,
        note: info.Name || info.Description || &#39;&#39;,
        referenceNumber
      });
    }
  }

  return { allProperties: properties, sourcesByName: groupPropertiesBySource(properties), referenceIndex };
}

function extractEducationalNotesFromPubChemJson(data) {
  const record = data?.Record;
  const sections = record?.Section || [];
  const collected = {
    history: [],
    uses: [],
    production: [],
    safety: [],
    toxicity: [],
    environmental: [],
    biological: [],
    discovery: [],
    propertiesSummary: []
  };

  const targets = [
    { key: &#39;history&#39;, headings: [&#39;History&#39;, &#39;History and Discovery&#39;] },
    { key: &#39;discovery&#39;, headings: [&#39;Discovery&#39;] },
    { key: &#39;uses&#39;, headings: [&#39;Uses&#39;, &#39;Use&#39;, &#39;Applications&#39;] },
    { key: &#39;production&#39;, headings: [&#39;Production&#39;, &#39;Preparation&#39;] },
    { key: &#39;safety&#39;, headings: [&#39;Safety&#39;, &#39;Safety and Hazards&#39;, &#39;Hazards&#39;, &#39;Health Hazards&#39;] },
    { key: &#39;toxicity&#39;, headings: [&#39;Toxicity&#39;] },
    { key: &#39;environmental&#39;, headings: [&#39;Environmental Effects&#39;, &#39;Environmental Hazard&#39;] },
    { key: &#39;biological&#39;, headings: [&#39;Biological Role&#39;] },
    { key: &#39;propertiesSummary&#39;, headings: [&#39;Description&#39;, &#39;Summary&#39;, &#39;Overview&#39;] }
  ];

  const flatSections = flattenSections(sections);
  for (const section of flatSections) {
    const heading = section.TOCHeading || &#39;&#39;;
    const target = targets.find(item =&gt; item.headings.some(h =&gt; heading.toLowerCase() === h.toLowerCase()));
    if (!target) continue;
    const notes = extractSectionText(section);
    if (notes.length &gt; 0) {
      collected[target.key].push(...notes);
    }
  }

  return collected;
}

function extractPropertyNotesFromPubChemProperties(allProperties) {
  const notesByProperty = {};
  for (const item of allProperties) {
    if (!item.note || typeof item.note !== &#39;string&#39;) continue;
    const note = item.note.trim();
    if (!note) continue;
    const propertyKey = item.property || &#39;Unknown&#39;;
    if (!notesByProperty[propertyKey]) {
      notesByProperty[propertyKey] = new Set();
    }
    notesByProperty[propertyKey].add(note);
  }

  const cleaned = {};
  for (const [property, noteSet] of Object.entries(notesByProperty)) {
    const uniqueNotes = Array.from(noteSet)
      .map(note =&gt; note.replace(/\s+/g, &#39; &#39;).trim())
      .filter(note =&gt; note &amp;&amp; note.toLowerCase() !== property.toLowerCase());

    if (uniqueNotes.length &lt;= 1) {
      continue;
    }

    cleaned[property] = uniqueNotes;
  }

  return cleaned;
}

function flattenSections(sectionList) {
  const flattened = [];
  for (const section of sectionList) {
    flattened.push(section);
    const childSections = section?.Section || [];
    if (childSections.length &gt; 0) {
      flattened.push(...flattenSections(childSections));
    }
  }
  return flattened;
}

function extractSectionText(section) {
  const notes = [];
  const infoList = section?.Information || [];
  for (const info of infoList) {
    const value = extractInfoValue(info);
    if (value &amp;&amp; value.trim()) {
      notes.push(value.trim());
    }
  }
  return notes;
}

function buildReferenceIndex(references) {
  const index = {};
  for (const ref of references) {
    if (ref.ReferenceNumber != null) {
      index[ref.ReferenceNumber] = ref;
    }
  }
  return index;
}

function extractInfoValue(info) {
  const markup = info?.Value?.StringWithMarkup;
  if (Array.isArray(markup) &amp;&amp; markup.length &gt; 0) {
    return markup.map(item =&gt; item.String).join(&#39;&#39;);
  }

  if (typeof info?.Value?.String === &#39;string&#39;) {
    return info.Value.String;
  }

  if (typeof info?.Value?.Number === &#39;number&#39;) {
    return info.Value.Number.toString();
  }

  return null;
}

function parseNumericValue(rawValue) {
  const valueMatch = rawValue.match(/[\d.¬±+\-]/g);
  const numeric = valueMatch ? parseFloat(valueMatch.join(&#39;&#39;)) : null;
  return Number.isFinite(numeric) ? numeric : null;
}

function pickPropertyList(allProperties, names) {
  for (const name of names) {
    const matches = allProperties.filter(item =&gt; item.property === name);
    if (matches.length &gt; 0) return matches;
  }
  return null;
}

function groupPropertiesBySource(allProperties) {
  const sources = {};
  for (const item of allProperties) {
    const sourceList = splitSources(item.source);
    for (const sourceName of sourceList) {
      const key = normalizeSourceKey(sourceName);
      if (!sources[key]) {
        sources[key] = {
          source: sourceName,
          sourceUrl: item.sourceUrl || &#39;&#39;,
          licenseUrl: item.licenseUrl || &#39;&#39;,
          licenseNote: item.licenseNote || &#39;&#39;,
          referenceNumber: item.referenceNumber ?? null,
          fields: {}
        };
      }

      if (!sources[key].fields[item.property]) {
        sources[key].fields[item.property] = [];
      }

      sources[key].fields[item.property].push({
        value: item.value,
        rawValue: item.rawValue,
        note: item.note || &#39;&#39;
      });
    }
  }

  return sources;
}

function splitSources(sourceText) {
  if (!sourceText) return [&#39;Unknown&#39;];
  return sourceText
    .split(/\s*[;|]\s*|\s*\/\s*|\s*,\s*/)
    .map(s =&gt; s.trim())
    .filter(Boolean);
}

function normalizeSourceKey(sourceName) {
  return sourceName.toLowerCase().replace(/[^a-z0-9]+/g, &#39;-&#39;).replace(/^-|-$/g, &#39;&#39;);
}

function flattenSourceBlock(sourceData) {
  const flattened = {
    source: sourceData.source,
    sourceUrl: sourceData.sourceUrl || &#39;&#39;,
    licenseUrl: sourceData.licenseUrl || &#39;&#39;,
    licenseNote: sourceData.licenseNote || &#39;&#39;,
    referenceNumber: sourceData.referenceNumber ?? null
  };

  const fieldMap = {
    &#39;Atomic Weight&#39;: &#39;atomicMass&#39;,
    &#39;Electronegativity&#39;: &#39;electronegativity&#39;,
    &#39;Ionization Energy&#39;: &#39;ionizationEnergy&#39;,
    &#39;Atomic Radius&#39;: &#39;atomicRadius&#39;,
    &#39;Electron Affinity&#39;: &#39;electronAffinity&#39;,
    &#39;Melting Point&#39;: &#39;meltingPoint&#39;,
    &#39;Boiling Point&#39;: &#39;boilingPoint&#39;,
    &#39;Density&#39;: &#39;density&#39;,
    &#39;Thermal Conductivity&#39;: &#39;thermalConductivity&#39;,
    &#39;Electron Configuration&#39;: &#39;electronConfiguration&#39;,
    &#39;Oxidation States&#39;: &#39;oxidationStates&#39;,
    &#39;Ground Level&#39;: &#39;groundLevel&#39;,
    &#39;Physical Description&#39;: &#39;physicalDescription&#39;,
    &#39;Element Classification&#39;: &#39;elementClassification&#39;,
    &#39;Standard Molar Entropy&#39;: &#39;standardMolarEntropy&#39;,
    &#39;Specific Heat Capacity&#39;: &#39;specificHeatCapacity&#39;
  };

  for (const [pubchemField, canonicalField] of Object.entries(fieldMap)) {
    if (sourceData.fields[pubchemField] &amp;&amp; sourceData.fields[pubchemField].length &gt; 0) {
      const firstValue = sourceData.fields[pubchemField][0];
      flattened[canonicalField] = firstValue.value;
      if (firstValue.rawValue !== firstValue.value.toString()) {
        flattened[`${canonicalField}_raw`] = firstValue.rawValue;
      }
      if (firstValue.note) {
        flattened[`${canonicalField}_note`] = firstValue.note;
      }
    }
  }

  return flattened;
}

/**
 * NEW: Consolidate all sources into single properties object.
 * Priority: DoE/Jefferson Lab &gt; NIST &gt; LANL &gt; IUPAC &gt; PubChem
 * Returns both properties AND source attribution for non-default values
 */
function consolidatePropertiesWithPriority(sources) {
  const properties = {};
  const DEFAULT_SOURCE = &#39;jefferson-lab&#39;; // DoE and Jefferson share same URL; use Jefferson as label
  
  const fieldPriority = [
    &#39;jefferson-lab&#39;,                  // Primary (DoE shares this URL)
    &#39;u-s-department-of-energy&#39;,       // Same as Jefferson Lab
    &#39;nist-physical-measurement-laboratory&#39;,
    &#39;los-alamos-national-laboratory&#39;,
    &#39;iupac-commission-on-isotopic-abundances-and-atomic-weights-ciaaw&#39;,
    &#39;pubchem-elements&#39;
  ];

  const propertyFields = [
    &#39;atomicMass&#39;, &#39;electronegativity&#39;, &#39;ionizationEnergy&#39;, &#39;atomicRadius&#39;,
    &#39;electronAffinity&#39;, &#39;meltingPoint&#39;, &#39;boilingPoint&#39;, &#39;density&#39;,
    &#39;thermalConductivity&#39;, &#39;electronConfiguration&#39;, &#39;oxidationStates&#39;,
    &#39;groundLevel&#39;, &#39;physicalDescription&#39;, &#39;elementClassification&#39;,
    &#39;standardMolarEntropy&#39;, &#39;specificHeatCapacity&#39;
  ];

  // For each property, find the highest-priority source that has it
  for (const field of propertyFields) {
    let foundValue = null;
    let foundSource = null;

    for (const sourceKey of fieldPriority) {
      const source = sources[sourceKey];
      if (source &amp;&amp; source[field] !== undefined) {
        foundValue = source[field];
        foundSource = sourceKey;
        break;
      }
    }

    // Only include if found
    if (foundValue !== null) {
      // If from default source, just store the value
      if (foundSource === DEFAULT_SOURCE) {
        properties[field] = foundValue;
      } else {
        // If from alternate source, store value + source attribution
        properties[field] = foundValue;
        properties[`${field}_source`] = foundSource;
      }
    }
  }

  return properties;
}

function buildPropertySourceReferences(sources) {
  const sourceMap = {};
  const fieldPriority = [
    &#39;jefferson-lab&#39;,
    &#39;u-s-department-of-energy&#39;,
    &#39;nist-physical-measurement-laboratory&#39;,
    &#39;los-alamos-national-laboratory&#39;,
    &#39;iupac-commission-on-isotopic-abundances-and-atomic-weights-ciaaw&#39;,
    &#39;pubchem-elements&#39;
  ];

  const propertyFields = [
    &#39;atomicMass&#39;, &#39;electronegativity&#39;, &#39;ionizationEnergy&#39;, &#39;atomicRadius&#39;,
    &#39;electronAffinity&#39;, &#39;meltingPoint&#39;, &#39;boilingPoint&#39;, &#39;density&#39;,
    &#39;thermalConductivity&#39;, &#39;electronConfiguration&#39;, &#39;oxidationStates&#39;,
    &#39;groundLevel&#39;, &#39;physicalDescription&#39;, &#39;elementClassification&#39;,
    &#39;standardMolarEntropy&#39;, &#39;specificHeatCapacity&#39;
  ];

  for (const field of propertyFields) {
    for (const sourceKey of fieldPriority) {
      const source = sources[sourceKey];
      if (source &amp;&amp; source[field] !== undefined) {
        sourceMap[field] = sourceKey;
        break;
      }
    }
  }

  return sourceMap;
}

/**
 * Compare current element data against PubChem authoritative values
 * Shows ALL sources and their values from PubChem for comparison
 * 
 * CRITICAL FOR GAME: Atomic weight MUST be a singular precise value, not a range
 * Game uses atomicMass for stoichiometric calculations - ranges cause errors
 */
function compareWithPubChem(elementData, pubchemData) {
  if (!pubchemData) return [];
  
  const discrepancies = [];
  const fieldsToCheck = [&#39;atomicMass&#39;, &#39;electronegativity&#39;, &#39;ionizationEnergy&#39;, &#39;atomicRadius&#39;, &#39;electronAffinity&#39;, &#39;meltingPoint&#39;, &#39;boilingPoint&#39;, &#39;density&#39;, &#39;thermalConductivity&#39;];
  
  fieldsToCheck.forEach(field =&gt; {
    if (pubchemData[field] &amp;&amp; Array.isArray(pubchemData[field])) {
      const nistValue = elementData.nist?.[field];
      const iupacValue = elementData.iupac?.[field];
      const nistSource = elementData.nist?.source;
      
      // ATOMIC WEIGHT SPECIAL CHECK: Must be singular, not range
      if (field === &#39;atomicMass&#39;) {
        if (nistValue &amp;&amp; (nistValue.toString().includes(&#39;‚Äì&#39;) || nistValue.toString().includes(&#39;¬±&#39;))) {
          discrepancies.push({
            field,
            severity: &#39;ERROR&#39;,
            issue: &#39;Atomic weight contains range/uncertainty - game needs singular precise value&#39;,
            current: { nist: nistValue, iupac: iupacValue, source: nistSource },
            pubchemSources: pubchemData[field],
            action: &#39;Must select single authoritative value from available sources&#39;
          });
        }
      }
      
      // Check if our values appear in ANY of the PubChem sources
      const foundMatch = pubchemData[field].some(source =&gt; 
        Math.abs(parseFloat(source.value) - parseFloat(nistValue || 0)) &lt; 0.001 ||
        Math.abs(parseFloat(source.value) - parseFloat(iupacValue || 0)) &lt; 0.001
      );
      
      if (!foundMatch &amp;&amp; nistValue) {
        discrepancies.push({
          field,
          severity: &#39;WARNING&#39;,
          issue: &#39;Value not found in PubChem sources - may be outdated&#39;,
          current: { nist: nistValue, iupac: iupacValue, source: nistSource },
          pubchemSources: pubchemData[field],
          mismatch: true
        });
      }
    }
  });
  
  return discrepancies;
}

// ============================================================================
// MAIN LOGIC
// ============================================================================

console.log(&#39;üîç Element Data Regenerator\n&#39;);

// Analyze current state
const analysis = analyzeExistingElements();

if (!analysis) {
  process.exit(1);
}

console.log(`\nüìà Status:`);
console.log(`   Total files: ${analysis.totalFiles}`);
console.log(`   Files needing update (phase data): ${analysis.filesNeedingUpdate.length}`);

if (analysis.filesNeedingUpdate.length &gt; 0) {
  console.log(`\n   Missing fields:`);
  analysis.filesNeedingUpdate.forEach(({ file, missing }) =&gt; {
    console.log(`     - ${file}: ${missing.join(&#39;, &#39;)}`);
  });
}

// Determine action
if (EXPORT_RAW_MODE) {
  console.log(&#39;\nüß™ EXPORT RAW MODE: Fetching PubChem data and writing to temp folder...\n&#39;);
  ensureTempOutputDir();

  let files = fs.readdirSync(ELEMENTS_DIR).filter(f =&gt; f.endsWith(&#39;.json&#39;));
  if (Number.isFinite(EXPORT_LIMIT)) {
    files = files.slice(0, EXPORT_LIMIT);
  }

  (async () =&gt; {
    let successCount = 0;
    let failCount = 0;

    for (const file of files) {
      const filePath = path.join(ELEMENTS_DIR, file);
      const elementData = JSON.parse(fs.readFileSync(filePath, &#39;utf8&#39;));

      console.log(`üì¶ Exporting ${elementData.symbol} (${elementData.name})...`);

      const pubchemData = await fetchPubChemElementData(elementData.atomicNumber, elementData.symbol);

      if (!pubchemData) {
        console.log(`   ‚ö†Ô∏è  PubChem fetch failed; skipping`);
        failCount += 1;
        continue;
      }

      // Flatten sourcesByName into per-source blocks
      const flattenedSources = {};

      if (pubchemData &amp;&amp; pubchemData.sourcesByName) {
        for (const [key, sourceData] of Object.entries(pubchemData.sourcesByName)) {
          flattenedSources[key] = flattenSourceBlock(sourceData);
        }
      }

      // NEW: Consolidate sources into single properties object
      // DoE/Jefferson as primary, other sources only for gaps
      const consolidatedProperties = consolidatePropertiesWithPriority(flattenedSources);

      // Build source references map with URLs and licenses
      const sourceReferences = {};
      if (pubchemData &amp;&amp; pubchemData.sourcesByName) {
        for (const [key, sourceData] of Object.entries(pubchemData.sourcesByName)) {
          sourceReferences[key] = {
            name: sourceData.source || key,
            url: sourceData.sourceUrl || &#39;&#39;,
            licenseUrl: sourceData.licenseUrl || &#39;&#39;,
            licenseNote: sourceData.licenseNote || &#39;&#39;
          };
        }
      }

      const exportPayload = {
        atomicNumber: elementData.atomicNumber,
        symbol: elementData.symbol,
        name: elementData.name,
        elementCategory: elementData.elementCategory,
        chemicalBlock: elementData.chemicalBlock,
        defaultSource: &#39;jefferson-lab (U.S. Dept of Energy)&#39;,
        _comment_properties: &#39;Property values from primary source (Jefferson Lab/DoE). Fields with _source suffix indicate fallback from alternate source.&#39;,
        properties: consolidatedProperties,
        states: buildPhaseDataFromProperties(consolidatedProperties),
        education: {
          _comment: &#39;Educational notes grouped by type for wiki generation.&#39;,
          history: pubchemData?.education?.history || [],
          discovery: pubchemData?.education?.discovery || [],
          uses: pubchemData?.education?.uses || [],
          production: pubchemData?.education?.production || [],
          safety: pubchemData?.education?.safety || [],
          toxicity: pubchemData?.education?.toxicity || [],
          environmental: pubchemData?.education?.environmental || [],
          biological: pubchemData?.education?.biological || [],
          propertiesSummary: pubchemData?.education?.propertiesSummary || [],
          propertyNotes: pubchemData?.education?.propertyNotes || {}
        },
        meta: {
          generatedAt: new Date().toISOString(),
          pubchemUrl: `https://pubchem.ncbi.nlm.nih.gov/element/${elementData.atomicNumber}`,
          pubchemSource: &#39;PubChem PUG-View (NIH - multiple authoritative sources)&#39;,
          dataSources: sourceReferences
        }
      };

      const outputPath = path.join(TEMP_OUTPUT_DIR, file);
      fs.writeFileSync(outputPath, JSON.stringify(exportPayload, null, 2));
      successCount += 1;
    }

    console.log(`\n‚úÖ Export complete. Wrote ${successCount} files to:`);
    console.log(`   ${TEMP_OUTPUT_DIR}`);
    if (failCount &gt; 0) {
      console.log(`‚ö†Ô∏è  ${failCount} files skipped due to PubChem fetch failures.`);
    }
    console.log(&#39;\nDone.&#39;);
  })();
} else if (UPDATE_MODE) {
  console.log(&#39;\n‚öôÔ∏è  UPDATE MODE: Validating against PubChem and adding new fields...\n&#39;);
  console.log(&#39;Will update the following files:&#39;);
  analysis.filesNeedingUpdate.forEach(({ file, missing }) =&gt; {
    console.log(`  ‚úèÔ∏è  ${file} (adding: ${missing.join(&#39;, &#39;)})`);
  });
  console.log(&#39;\nTODO: Implement phase data fetching from PubChem&#39;);
} else if (RECREATE_MODE) {
  console.log(&#39;\n‚ö†Ô∏è  RECREATE MODE: This will rebuild all 118 elements from scratch!&#39;);
  console.log(&#39;This should ALMOST NEVER be used. Use --update for incremental changes.\n&#39;);
  console.log(&#39;TODO: Implement full rebuild from PubChem/NIST&#39;);
} else {
  // Default mode: Check against PubChem authoritative data
  console.log(&#39;\nüîé CHECK MODE: Comparing current data against PubChem...\n&#39;);
  console.log(&#39;Fetching PubChem data for verification (this may take a moment)...\n&#39;);
  
  const files = fs.readdirSync(ELEMENTS_DIR).filter(f =&gt; f.endsWith(&#39;.json&#39;)).slice(0, 5); // Sample first 5 for quick test
  
  (async () =&gt; {
    let discrepanciesFound = 0;
    
    for (const file of files) {
      const filePath = path.join(ELEMENTS_DIR, file);
      const elementData = JSON.parse(fs.readFileSync(filePath, &#39;utf8&#39;));
      
      console.log(`\nüìã ${elementData.symbol} (${elementData.name}):`);
      
      const pubchemData = await fetchPubChemElementData(elementData.atomicNumber, elementData.symbol);
      
      if (!pubchemData) {
        console.log(`   ‚ö†Ô∏è  Could not validate against PubChem`);
        continue;
      }
      
      const discrepancies = compareWithPubChem(elementData, pubchemData);
      
      if (discrepancies.length === 0) {
        console.log(`   ‚úÖ All values validated`);
      } else {
        discrepanciesFound += discrepancies.length;
        discrepancies.forEach(({ field, severity, issue, current, pubchemSources, action }) =&gt; {
          const icon = severity === &#39;ERROR&#39; ? &#39;‚ùå&#39; : &#39;‚ö†Ô∏è&#39;;
          console.log(`   ${icon} ${severity}: ${field}`);
          console.log(`       Issue: ${issue}`);
          console.log(`       Current: NIST=${current.nist}, IUPAC=${current.iupac}`);
          console.log(`       Source: ${current.source}`);
          if (pubchemSources &amp;&amp; Array.isArray(pubchemSources)) {
            console.log(`       PubChem sources available (${pubchemSources.length}):`);
            pubchemSources.forEach((source, idx) =&gt; {
              console.log(`         [${idx + 1}] ${source.rawValue} - ${source.source}`);
              if (source.note) console.log(`             Note: ${source.note}`);
            });
          }
          if (action) console.log(`       Action: ${action}`);
        });
      }
    }
    
    console.log(`\n${&#39;=&#39;.repeat(60)}`);
    if (discrepanciesFound === 0) {
      console.log(`‚úÖ Check complete. All sampled elements match PubChem data.\n`);
    } else {
      console.log(`‚ö†Ô∏è  Check complete. Found ${discrepanciesFound} discrepancies.\n`);
      console.log(`   Run with --update to fetch corrected data from PubChem.\n`);
    }
    
    console.log(`\nüìã POST-CHECK VALIDATION REQUIRED:`);
    console.log(`   TODO: Verify atomic weight values are SINGULAR and PRECISE`);
    console.log(`   - Game calculations depend on precise atomicMass (no ranges)`);
    console.log(`   - Must select authoritative source consistently across all elements`);
    console.log(`   - Per-element handling may be needed for elements with multiple valid sources`);
    console.log(`   - Recommend: NIST for consistency (but verify no ranges present)`);
    console.log(`\n   TODO: After --update run, manually inspect:`)
    console.log(`   - Any atomicMass values containing ¬± or ‚Äì (ranges)`);
    console.log(`   - Per-element source selection for game use`);
    console.log(`   - Ensure phase data was successfully added`);
    
    console.log(&#39;\nDone.&#39;);
  })();
}
</code></pre>
        </details>
      </section>
    
        </article>
      </main>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
  <script>
    // Lazy-load Kekule only when molecule viewer is expanded (saves bandwidth on low-end devices)
    (() => {
      let smilesDrawerLoaded = false
      let smilesDrawerLoading = false
      
      // Convert explicit SMILES like [CH3][CH](OH)[CH3] to standard like CC(O)C
      const explicitToStandard = (smiles) => {
        return smiles
          // Common organic groups - order matters (longer patterns first)
          .replace(/\[CH3\]/g, 'C')
          .replace(/\[CH2\]/g, 'C')
          .replace(/\[CH\]/g, 'C')
          .replace(/\[OH\]/g, 'O')
          .replace(/\[NH2\]/g, 'N')
          .replace(/\[NH\]/g, 'N')
          .replace(/\[SH\]/g, 'S')
          // Single atoms in brackets (keep aromatic lowercase)
          .replace(/\[C\]/g, 'C')
          .replace(/\[N\]/g, 'N')
          .replace(/\[O\]/g, 'O')
          .replace(/\[S\]/g, 'S')
          .replace(/\[P\]/g, 'P')
          .replace(/\[F\]/g, 'F')
          .replace(/\[Cl\]/g, 'Cl')
          .replace(/\[Br\]/g, 'Br')
          .replace(/\[I\]/g, 'I')
          // Bare atoms in branches - H is implicit in standard SMILES
          .replace(/\(OH\)/g, '(O)')
          .replace(/\(NH2\)/g, '(N)')
          .replace(/\(NH\)/g, '(N)')
          .replace(/\(SH\)/g, '(S)')
      }
      
      const loadSmilesDrawer = async () => {
        if (smilesDrawerLoaded) return
        if (smilesDrawerLoading) {
          return new Promise(resolve => {
            const check = setInterval(() => {
              if (smilesDrawerLoaded) { clearInterval(check); resolve() }
            }, 50)
          })
        }
        smilesDrawerLoading = true
        
        // Load SmilesDrawer from CDN (much simpler than Kekule)
        await new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = 'https://unpkg.com/smiles-drawer@2.1.7/dist/smiles-drawer.min.js'
          script.onload = resolve
          script.onerror = reject
          document.body.appendChild(script)
        })
        
        smilesDrawerLoaded = true
        smilesDrawerLoading = false
      }
      
      const initMolecule = async (node) => {
        if (node.dataset.initialized) return
        node.dataset.initialized = 'true'
        
        const rawSmiles = node.getAttribute('data-smiles')
        if (!rawSmiles) return
        
        // Convert explicit format to standard if needed
        const smiles = explicitToStandard(rawSmiles)
        
        try {
          await loadSmilesDrawer()
          
          const drawer = new SmilesDrawer.SvgDrawer({ 
            width: 300, 
            height: 200,
            explicitHydrogens: true,
            terminalCarbons: true,
            compactDrawing: false
          })
          
          console.log('Parsing SMILES:', rawSmiles, '->', smiles)
          SmilesDrawer.parse(smiles, (tree) => {
            console.log('Parse success, tree:', tree)
            const svgElement = drawer.draw(tree, null, 'light')
            console.log('SVG element:', svgElement)
            node.innerHTML = ''
            node.appendChild(svgElement)
          }, (err) => {
            console.error('SMILES parse error for "' + smiles + '":', err)
            node.innerHTML = '<code>' + rawSmiles + '</code>'
          })
        } catch (err) {
          console.error('SmilesDrawer load error:', err)
          node.innerHTML = '<code>' + smiles + '</code>'
        }
      }
      
      // Use IntersectionObserver for lazy loading when scrolled into view
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initMolecule(entry.target)
            observer.unobserve(entry.target)
          }
        })
      }, { rootMargin: '100px' })
      
      // Also handle <details> expansion for molecules inside collapsed sections
      document.addEventListener('toggle', (e) => {
        if (e.target.tagName === 'DETAILS' && e.target.open) {
          const molecules = e.target.querySelectorAll('[data-smiles]:not([data-initialized])')
          molecules.forEach(node => initMolecule(node))
        }
      }, true)
      
      // Observe all molecule nodes
      const init = () => {
        const nodes = document.querySelectorAll('[data-smiles]')
        nodes.forEach(node => observer.observe(node))
      }
      
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init)
      } else {
        init()
      }
    })()
  </script>
</body>
</html>