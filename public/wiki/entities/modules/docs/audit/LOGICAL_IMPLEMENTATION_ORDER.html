<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LOGICAL_IMPLEMENTATION_ORDER.md - Boiling Water Wiki</title>
  <link rel="stylesheet" href="/wiki/assets/styles.css" />
  <!-- Kekule CSS loaded lazily when molecule viewer is needed -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />
</head>
<body>
  <div class="wiki-layout">
    <div class="wiki-main">
      <header class="wiki-topbar">
        <details class="wiki-menu" aria-label="Menu">
          <summary>‚ò∞ Menu</summary>
          <nav class="wiki-menu-links">
            <div class="menu-section">
              <div class="menu-heading">Main</div>
              <a href="/wiki/index.html">üìö Main page</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Science</div>
              <a href="/wiki/entities/elements/index.html">‚öõÔ∏è Elements</a>
              <a href="/wiki/entities/compounds/index.html">üß™ Compounds</a>
              <a href="/wiki/entities/solutions/index.html">üíß Solutions</a>
              <a href="/wiki/entities/phases/index.html">‚ùÑÔ∏è Phases</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Game Structure</div>
              <a href="/wiki/entities/levels/index.html">üìä Levels</a>
              <a href="/wiki/entities/experiments/index.html">üî¨ Experiments</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Code Reference</div>
              <a href="/wiki/entities/formulas/index.html">üìê Formulas</a>
              <a href="/wiki/entities/processes/index.html">‚öôÔ∏è Processes</a>
              <a href="/wiki/entities/modules/index.html">üì¶ Modules</a>
              <a href="/wiki/entities/symbols/index.html">üî£ Symbols</a>
              <a href="/wiki/entities/public/index.html">üìÅ Public Files</a>
              <a href="/wiki/entities/assets/index.html">üñºÔ∏è Assets</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Repository</div>
              <a href="/wiki/entities/docs/index.html">üìñ Docs</a>
              <a href="/wiki/entities/scripts/index.html">üß∞ Scripts</a>
              <a href="/wiki/entities/styles/index.html">üé® Styles</a>
              <a href="/wiki/entities/root-files/index.html">üóÇÔ∏è Root Files</a>
              <a href="/wiki/entities/reports/changes-since-last-commit.html">üß≠ Changes</a>
            </div>
            <div class="wiki-menu-divider"></div>
            <a href="/">‚¨ÖÔ∏è Back to Game</a>
          </nav>
        </details>
        
        <nav class="breadcrumbs" aria-label="Breadcrumb">
          <a href="/wiki/../../../index.html">Main</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../index.html">Modules</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../docs/index.html">docs</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../docs/audit/index.html">audit</a> <span class="breadcrumb-sep">‚Ä∫</span> <span>LOGICAL_IMPLEMENTATION_ORDER.md</span>
        </nav>
        <div class="wiki-topbar-title">LOGICAL_IMPLEMENTATION_ORDER.md</div>
      </header>
      <main class="wiki-content">
        
        <article class="wiki-article">
          
      
    <aside class="infobox">
      <div class="infobox-title">LOGICAL_IMPLEMENTATION_ORDER.md</div>
      
      <div class="infobox-row">
        <div class="infobox-label">Type</div>
        <div class="infobox-value">Module</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">File type</div>
        <div class="infobox-value">md</div>
      </div>
    
    </aside>
  
      <section class="section">
        
  <div class="entity-header">
    <h1>LOGICAL_IMPLEMENTATION_ORDER.md</h1>
    <p class="subtitle">Module</p>
  </div>

      </section>
      
      <section class="section" id="source-file">
        <h2>Source file</h2>
        <p><code>docs\audit\LOGICAL_IMPLEMENTATION_ORDER.md</code></p>
        <details>
          <summary>View source code</summary>
          <pre class="line-numbers"><code class="language-markdown"># Logical Implementation Order for Industry Standards Compliance

&gt; **Purpose:** Priority labels (P1, P2, P3) don&#39;t reflect implementation dependencies. This document defines the optimal sequence based on logical prerequisites and enablers.

**Last Updated:** 2026-02-04

---

## üéØ CURRENT STATUS (2026-02-04)

### ‚úÖ PHASE 0 (COMPLETE - Week 1 Enablers)
- ‚úÖ #9 Stale TODOs: 3 remaining (all reference doc links, not code tasks)
- ‚úÖ #10 Debug Logging: Zero console.log in src/ (35 console statements are error/warn only)
- ‚úÖ #6 Complete ESLint: Production-grade v9 flat config, integrated in CI
- ‚úÖ #8 Environment Config: Vite-based APP_ENV module with safe defaults

**Impact:** Clean codebase, production ESLint, environment variables ready

### ‚úÖ PHASE 1 (COMPLETE - Week 2-3 Safety Net)
- ‚úÖ #1 Unit Tests: 77 passing (6 formula files + 1 integration file + 1 unitUtils)
- ‚úÖ #5 CI/CD Testing: Full pipeline (lint, test, build, lighthouse, sonarcloud)
- ‚úÖ SonarCloud: Integrated and auto-scanning on push

**Impact:** Every commit auto-validated, safe to refactor

### üöÄ PHASE 2 (READY TO START - Week 4-7 Architecture)

**Next Steps (Priority Order):**
1. **#4 State Management (1-2 weeks)** - Install Zustand, create game/workshop stores, migrate shared app state (keep hot simulation state local)
2. **#2 Time Stepping (1-2 weeks)** - Web Worker physics loop for extreme time compression (see TIME_STEPPING_TODO.md)
3. **#3 Component Refactoring (3-4 weeks)** - Split GameScene.jsx (1857 lines) into 30 focused components
4. **#2 TypeScript (4-6 weeks, parallel)** - Incremental migration: utils ‚Üí constants ‚Üí components

**Prerequisites Met:** ‚úÖ ESLint ready to catch circular deps ‚úÖ CI/CD validates every commit ‚úÖ Tests validate behavior

**No blockers. Ready to proceed.**

---

---

## The Problem with Priority-Based Ordering

### Original Plan (By Priority)

```
Phase 1 (Weeks 1-2): Critical Issues
‚îú‚îÄ #1 Unit Tests
‚îú‚îÄ #2 TypeScript
‚îú‚îÄ #3 Massive Components
‚îú‚îÄ #4 State Management
‚îî‚îÄ #5 CI/CD Testing

Phase 2 (Weeks 3-5): Medium Priority
‚îú‚îÄ #6 ESLint
‚îú‚îÄ #7 CSS Modular
‚îî‚îÄ #8 Environment Config

Phase 3 (Week 6): Low Priority
‚îú‚îÄ #9 TODOs
‚îú‚îÄ #10 Debug Logging
‚îú‚îÄ #11 Error Boundaries
‚îú‚îÄ #12 Bundle Analysis
‚îî‚îÄ #13 PropTypes
```

### Why This Fails

**Scenario 1: Refactoring Without ESLint**

```javascript
// Week 2: You split GameScene.jsx into 30 components
// No ESLint rules for imports/circular deps yet

// File A.jsx
import { calculateTemp } from &#39;./utils/physics&#39;
import { roomState } from &#39;./B&#39;

// File B.jsx
import { pressure } from &#39;./utils/physics&#39;
import { gameState } from &#39;./A&#39;  // ‚Üê Circular dependency!

// Code compiles, but runtime: undefined values
// Week 4: You add complete ESLint
// ESLint: &quot;Error: Circular dependency detected&quot;
// Now you have to refactor 30 newly-created files
```

**Cost:** 2-3 days reworking fresh code that ESLint would have prevented.

---

**Scenario 2: Tests Without Environment Config**

```javascript
// Week 2: Writing unit tests
// test/physics.test.js
const API_URL = &#39;http://localhost:3000/api&#39;  // ‚Üê Hardcoded

describe(&#39;calculateBoilingPoint&#39;, () =&gt; {
  it(&#39;fetches data from API&#39;, async () =&gt; {
    const mockFetch = jest.fn()
    global.fetch = mockFetch
    await loadSubstance(&#39;water&#39;)
    expect(mockFetch).toHaveBeenCalledWith(&#39;http://localhost:3000/api/...&#39;)  // ‚Üê Hardcoded
  })
})

// Write 50 test files like this

// Week 5: Add environment config
// Now all 50 test files need updating:
import CONFIG from &#39;../config&#39;
expect(mockFetch).toHaveBeenCalledWith(CONFIG.api.url + &#39;/...&#39;)
```

**Cost:** 4-6 hours retrofitting all tests to use environment variables.

---

**Scenario 3: Refactoring with TODOs/Debug Logs**

```javascript
// GameScene.jsx (before split)
export function GameScene() {
  console.log(&#39;GameScene render&#39;)  // ‚Üê Debug log
  // TODO: Optimize this calculation
  const temp = calculateTemp()
  console.log(&#39;Temp:&#39;, temp)  // ‚Üê Debug log
  return &lt;div&gt;...&lt;/div&gt;
}

// Week 2: You split into 30 components
// Now each of 30 files has console.log and TODOs
// Week 6: You clean up TODOs and debug logs
// Have to edit 30 files instead of 1
```

**Cost:** 1-2 days cleaning scattered mess vs. 1 day cleaning centralized mess.

---

**Scenario 4: No CI/CD During Major Refactoring**

```javascript
// Week 3: Refactoring components
// You make 50 commits over 2 weeks
// Each commit might break something
// But you only test manually (occasionally)

// Week 5: Manual QA session
// QA: &quot;Physics calculation is broken&quot;
// You: &quot;Which commit broke it?&quot;
// QA: &quot;Not sure, just noticed today&quot;
// You: git bisect through 50 commits

// With CI/CD from Week 1:
// Every commit auto-tests
// Build fails immediately on breaking change
// You know exactly which commit broke it
// Fix in 10 minutes instead of 2 hours
```

**Cost:** 8-10 hours of debugging that CI/CD would have caught immediately.

---

## Logical Dependency Analysis

### Dependencies Between Issues

```
#8 (Environment Config)
  ‚Üì
  ‚îú‚îÄ‚Üí #1 (Unit Tests) ‚Üê needs CONFIG for API URLs
  ‚îî‚îÄ‚Üí #5 (CI/CD) ‚Üê needs env vars for different environments

#6 (Complete ESLint)
  ‚Üì
  ‚îú‚îÄ‚Üí #3 (Component Refactor) ‚Üê catches circular deps, import issues
  ‚îú‚îÄ‚Üí #4 (State Management) ‚Üê enforces hook rules
  ‚îî‚îÄ‚Üí #2 (TypeScript) ‚Üê fewer conflicts with proper ESLint

#9 (TODOs) + #10 (Debug Logs)
  ‚Üì
  ‚îî‚îÄ‚Üí #3 (Component Refactor) ‚Üê cleaner code to split

#5 (CI/CD)
  ‚Üì
  ‚îú‚îÄ‚Üí #3 (Component Refactor) ‚Üê validates every change
  ‚îú‚îÄ‚Üí #4 (State Management) ‚Üê validates every change
  ‚îî‚îÄ‚Üí #2 (TypeScript) ‚Üê validates every change

#4 (State Management)
  ‚Üì
  ‚îî‚îÄ‚Üí #3 (Component Refactor) ‚Üê fewer props = easier to split

#3 (Component Refactor)
  ‚Üì
  ‚îî‚îÄ‚Üí #7 (CSS Modular) ‚Üê easier to organize CSS per-component
```

### Enablers vs. Blockers

| Issue | Type | Enables | Blocked By |
|-------|------|---------|------------|
| #9 TODOs | Enabler | Clean refactoring | Nothing |
| #10 Debug Logs | Enabler | Clean console | Nothing |
| #6 ESLint | Enabler | Catches issues early | Nothing |
| #8 Env Config | Enabler | Tests, CI/CD | Nothing |
| #5 CI/CD | Safety Net | Safe refactoring | #8 |
| #1 Tests | Safety Net | Safe refactoring | #8 |
| #4 State Mgmt | Simplifier | Easier components | #5, #1 |
| #3 Components | Major Refactor | Everything else | #6, #9, #10 |
| #2 TypeScript | Major Refactor | Type safety | #6 |
| #7 CSS | Polish | Clean styles | #3 |
| #11 Error Boundaries | Polish | Reliability | #3 |
| #12 Bundle Analysis | Polish | Optimization | #3, #2 |
| #13 PropTypes | Optional | Type checking | Nothing (skip if #2 soon) |

---

## Optimal Implementation Sequence

### **Phase 0: Quick Wins (Week 1)** 
*Enablers ‚Äî Make future work easier*

#### Day 1-2: Clean Up (2 days)

**#9 Stale TODOs (1 day)**
```bash
# Find all TODOs
grep -r &quot;TODO\|FIXME\|XXX&quot; src/ &gt; todos.txt

# Categorize: Implement / Create Issue / Delete
# Implement critical ones (safety checks)
# Delete speculative ones
# Create GitHub issues for enhancements

# Result: Clean codebase before refactoring
```

**Why first:**
- 1-day cleanup
- Prevents moving TODOs around during refactoring
- Some TODOs are actual bugs (forgotten safety checks)

**#10 Debug console.log (1 day)**
```bash
# Find all console.log
grep -rn &quot;console\.log&quot; src/ &gt; logs.txt

# Remove debug logs
# Wrap dev-only logs in NODE_ENV check
# Convert important logs to console.error/warn

# Result: Clean console for development
```

**Why first:**
- 1-day cleanup
- Cleaner console during refactoring
- Better performance
- Don&#39;t move debug logs to 30 files during split

---

#### Day 3-5: Enablers (3 days)

**#6 Complete ESLint Setup (1-2 days)**

```bash
# Install missing plugins
npm install --save-dev \
  eslint-plugin-import \
  eslint-plugin-jsx-a11y \
  eslint-config-prettier \
  eslint-plugin-security \
  eslint-plugin-no-unsanitized

# Update .eslintrc.json with all rules
# Run first lint: find 150+ issues
# Auto-fix 80% of them
# Manually fix remaining 20%

# Result: Production-grade linting
```

**Why now:**
- **Catches circular dependencies** during component refactoring
- **Enforces hook rules** during state management
- **Validates imports** as you split files
- **Prevents problems** instead of fixing them later
- **AI-specific:** Catches AI coding mistakes (long functions, complexity, unused vars)

**Critical:** If you refactor components WITHOUT complete ESLint, you&#39;ll create circular dependencies, unused imports, and wrong hook dependencies. Then ESLint catches them later = rework.

**AI Coding Note:** Since you&#39;re using AI-assisted development (GitHub Copilot, etc.), add these rules immediately:

```json
// .eslintrc.json - AI-specific rules
{
  &quot;rules&quot;: {
    &quot;complexity&quot;: [&quot;warn&quot;, 15],  // AI generates complex code
    &quot;max-lines-per-function&quot;: [&quot;warn&quot;, 100],  // AI generates long functions
    &quot;no-unused-vars&quot;: &quot;error&quot;,  // AI leaves unused code
    &quot;no-console&quot;: [&quot;warn&quot;, { &quot;allow&quot;: [&quot;error&quot;, &quot;warn&quot;] }],  // AI loves console.log
    &quot;@typescript-eslint/no-explicit-any&quot;: &quot;error&quot;,  // AI overuses &#39;any&#39;
    &quot;security/detect-object-injection&quot;: &quot;warn&quot;  // AI misses XSS
  }
}
```

**Auto-run note:** ESLint becomes **automatic** when CI/CD is added in #5 (lint gate). Until then, run `npm run lint` locally as needed.

These catch 80% of AI coding mistakes immediately in your editor.

**#8 Environment Configuration (1-2 days)**

```bash
# Create .env files
.env.example
.env.local
.env.staging

# Create config.js module
# Replace all hardcoded values
# Update CI/CD to use env vars

# Result: Development/staging/production separation
```

**Why now:**
- **Required by tests** (Issue #1) ‚Äî tests need CONFIG for API URLs
- **Required by CI/CD** (Issue #5) ‚Äî different envs need different configs
- **Prevents rework** ‚Äî don&#39;t write tests with hardcoded URLs then retrofit

---

### **Phase 1: Safety Net (Week 2-3)**
*Validation infrastructure before major changes*

#### Week 2: CI/CD Pipeline (1 week)

**#5 CI/CD Testing (1 week)**

```yaml
# .github/workflows/ci.yml (complete pipeline)
name: CI/CD Pipeline

on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm install
      - run: npm run lint  # ‚Üê Catches style issues

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm install
      - run: npm test  # ‚Üê Validates behavior
      - uses: codecov/codecov-action@v2  # ‚Üê Tracks coverage

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm install
      - run: npm run build  # ‚Üê Ensures it compiles
      - run: ls -lh dist/  # ‚Üê Check bundle size

  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm install
      - run: npm run build
      - uses: treosh/lighthouse-ci-action@v9  # ‚Üê Performance audit

# Every push auto-validates
# Pull requests show test status
# Broken builds blocked from merging
```

**Why now:**
- **Safety net for refactoring** ‚Äî Every change during Weeks 3-7 is auto-validated
- **Immediate feedback** ‚Äî Know within 5 minutes if commit broke something
- **Prevents integration hell** ‚Äî Small issues caught immediately vs. big mess later

**Critical Impact:** Issues #3 (components), #4 (state), #2 (TypeScript) involve 100+ commits over 4-6 weeks. Without CI/CD, you&#39;re manually testing. With CI/CD, automatic validation = 10x faster iteration.

---

#### Week 2: SonarCloud Setup (1-2 hours)

**SonarQube/SonarCloud (Quick Setup)**

```bash
# 1. Sign up at sonarcloud.io with GitHub account
# 2. Import Boilingwater.app repository
# 3. Add to CI/CD pipeline
```

```yaml
# .github/workflows/ci.yml (add after build job)
  sonarcloud:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Full history for blame data
      
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

```markdown
# Add badges to README.md
[![Quality Gate](https://sonarcloud.io/api/project_badges/measure?project=zawalonka_Boilingwater.app&amp;metric=alert_status)](https://sonarcloud.io/dashboard?id=zawalonka_Boilingwater.app)
[![Technical Debt](https://sonarcloud.io/api/project_badges/measure?project=zawalonka_Boilingwater.app&amp;metric=sqale_index)](https://sonarcloud.io/dashboard?id=zawalonka_Boilingwater.app)
[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=zawalonka_Boilingwater.app&amp;metric=code_smells)](https://sonarcloud.io/dashboard?id=zawalonka_Boilingwater.app)
```

**Why now:**
- **Free for public repos** ‚Äî No cost, full features
- **Immediate baseline** ‚Äî See current technical debt (probably 20-30 hours)
- **Track progress** ‚Äî Watch debt decrease as you refactor
- **Code smell detection** ‚Äî Finds duplicated code, overly complex functions
- **Security scanning** ‚Äî Catches vulnerabilities ESLint misses
- **Pull request feedback** ‚Äî Auto-comments on PRs with new issues
- **1-2 hours setup** ‚Äî Sign up, connect repo, add CI step, done

**What it catches that ESLint doesn&#39;t:**
- GameScene.jsx complexity score: 43 (should be &lt; 15) ‚Üí &quot;Split this file&quot;
- Duplicated code blocks across files ‚Üí &quot;Extract shared function&quot;
- Security vulnerabilities (SQL injection patterns, XSS risks)
- Cognitive complexity of nested conditions
- Technical debt estimates: &quot;23 hours to clean this codebase&quot;

**Result:** Auto-updating quality dashboard + badges showing progress as you implement fixes over Weeks 3-8.

**Documentation:** See [ISSUE_06_INCOMPLETE_ESLINT.md](ISSUE_06_INCOMPLETE_ESLINT.md#sonarqube--code-climate-beyond-eslint) for full details.

---

#### Week 2-3: Start Unit Tests (Ongoing)

**#1 Unit Tests (Start, 2-3 weeks total)**

```javascript
// Start with physics formulas (high ROI)
// Week 2: Test 10 physics functions (20 hours)
// Week 3: Test component rendering (20 hours)
// Week 4-5: Continue during refactoring (20 hours)
// Total: 60 hours over 4 weeks

// tests/utils/physics/latentHeat.test.js
import { calculateVaporizationEnergy } from &#39;../../../src/utils/physics/formulas/latentHeat&#39;

describe(&#39;calculateVaporizationEnergy&#39;, () =&gt; {
  it(&#39;calculates energy for water vaporization&#39;, () =&gt; {
    const energy = calculateVaporizationEnergy(1.0, 2257)  // 1kg water
    expect(energy).toBe(2257000)  // 2,257 kJ = 2,257,000 J
  })

  it(&#39;handles fractional mass&#39;, () =&gt; {
    const energy = calculateVaporizationEnergy(0.5, 2257)
    expect(energy).toBe(1128500)
  })

  it(&#39;throws on negative mass&#39;, () =&gt; {
    expect(() =&gt; calculateVaporizationEnergy(-1, 2257)).toThrow()
  })
})
```

**Why now:**
- **Tests validate refactoring** ‚Äî Split components with confidence
- **Physics correctness critical** ‚Äî Educational app needs accurate calculations
- **Can start small** ‚Äî Write tests as you refactor (not all upfront)

**Parallel work:** Tests can be written WHILE refactoring components. Test original code, refactor, verify tests still pass.

---

### **Phase 2: Architecture (Week 4-7)**
*Major refactoring with safety net in place*

#### Week 4-5: State Management First

**#4 State Management (1-2 weeks)**

```bash
# Install Zustand
npm install zustand

# Create stores
stores/gameStore.js  # Game state
stores/roomStore.js  # Room environment
stores/workshopStore.js  # Workshop/theme

# Migrate state from App.jsx to stores
# Test each migration (CI/CD validates)

# Result: Centralized state, no props drilling
```

**Why before component refactoring:**

```javascript
// Without Zustand (current):
&lt;GameScene 
  temperature={temp}
  waterMass={mass}
  burnerHeat={heat}
  roomPressure={pressure}
  altitude={alt}
  location={loc}
  workshop={ws}
  fluid={fluid}
  {...19 more props}
/&gt;

// With Zustand (after state management):
&lt;GameScene /&gt;
// Component gets state from store internally
// No prop passing

// Component refactoring is now:
// - Simpler (fewer props to track)
// - Easier (no prop threading through components)
// - Cleaner (each component gets what it needs)
```

**Critical:** Do state management BEFORE component splitting. Otherwise you&#39;re splitting components that pass 19 props ‚Üí 5 levels deep = nightmare. With centralized state, components are self-contained.

---

#### Week 5-7: Component Refactoring

**#3 Massive Components (3-4 weeks)**

```bash
# Week 5: Extract hooks (usePhysics, useRoomEnvironment, useDragging)
# Week 6: Split rendering (PotRenderer, BurnerRenderer, etc.)
# Week 7: Organize structure, test everything

# CI/CD validates every commit
# Tests ensure behavior unchanged
# ESLint catches circular deps

# Result: 30 focused components, each &lt;200 lines
```

**Why after state management + CI/CD + ESLint:**
- Zustand = No props drilling (easier to split)
- CI/CD = Every split validated automatically
- ESLint = Catches circular dependencies as you create them
- Tests = Ensure refactoring doesn&#39;t break behavior

**Timeline:**
- Week 5: Extract 5-7 hooks (15 hours)
- Week 6: Split into 15-20 components (25 hours)
- Week 7: Polish, organize, document (15 hours)

---

#### Week 4-10: TypeScript Migration (Parallel)

**#2 TypeScript (4-6 weeks, can run parallel)**

```bash
# Can start Week 4 (after ESLint complete)
# Run in parallel with component refactoring

# Week 4: Setup (tsconfig, types for dependencies)
# Week 5-6: Convert utils/ and constants/
# Week 7-8: Convert components/
# Week 9-10: Fix type errors, strict mode

# CI/CD validates TypeScript compilation
# Can merge incrementally (JS and TS coexist)

# Result: Full type safety
```

**Why parallel:**
- TypeScript migration is independent work
- Doesn&#39;t block component refactoring
- Can convert one file at a time (incremental)
- JS and TS coexist during transition

**Order within TypeScript:**
1. Utils/physics first (pure functions, easiest to type)
2. Constants/config (simple types)
3. Components last (complex props)

**#13 PropTypes:** Skip if doing TypeScript. TypeScript provides better type safety.

---

### **Phase 3: Polish (Week 8+)**
*Optimization after architecture is stable*

#### Week 8: CSS and Error Handling

**#7 CSS Modular (2-3 days)**

```bash
# After components are split
# Each component gets its own CSS file

# Before (monolithic):
src/styles/GameScene.css (1500 lines)

# After (modular):
src/styles/components/Pot.css (120 lines)
src/styles/components/Burner.css (100 lines)
src/styles/components/Temperature.css (80 lines)
# ... 8 more files

# Result: 40% size reduction, organized by component
```

**Why after component refactoring:**
- Components are split up (easier to organize CSS per-component)
- Know what CSS belongs where
- Don&#39;t reorganize CSS twice (once now, once after splitting components)

**#11 Error Boundaries (1-2 days)**

```javascript
// Add ErrorBoundary wrapper to each major component
&lt;ErrorBoundary&gt;
  &lt;GameScene /&gt;
&lt;/ErrorBoundary&gt;

&lt;ErrorBoundary&gt;
  &lt;ControlPanel /&gt;
&lt;/ErrorBoundary&gt;

// Nested boundaries for fine control
// Result: App never goes completely blank on error
```

**Why after component refactoring:**
- Components are stable (know where boundaries should go)
- Don&#39;t add boundaries, then restructure components, then move boundaries

---

#### Week 8+: Monitoring

**#12 Bundle Analysis (1-2 days)**

```bash
# Install rollup-plugin-visualizer
npm install --save-dev rollup-plugin-visualizer

# Configure vite.config.mjs
# Run build: opens interactive visualization

# Identify optimization opportunities
# - Heavy libraries
# - Duplicate code
# - Unused exports

# Result: Know exactly what&#39;s in bundle, optimize
```

**Why last:**
- Architecture is stable (know final bundle composition)
- TypeScript complete (accurate size)
- Components split (can lazy-load heavy ones)
- Makes sense to optimize once architecture is final

---

## Time and Effort Comparison

### Original Order (By Priority)

```
Week 1-2:  #1, #2, #3, #4, #5 (no ESLint, no env config)
           ‚Üì Create circular deps during refactor
Week 3-5:  #6, #7, #8 (add ESLint after refactoring)
           ‚Üì 200+ ESLint warnings in fresh code
           ‚Üì 2-3 days rework
Week 6:    #9, #10, #11, #12, #13
           ‚Üì Clean up TODOs scattered across 30 files

Total Time: 8 weeks + 1 week rework = 9 weeks
```

### Optimal Order (Logical Dependencies)

```
Week 1:    #9, #10, #6, #8 (enablers)
           ‚Üì Clean codebase, ESLint active, env config ready
Week 2-3:  #5, #1 (safety net)
           ‚Üì CI/CD validates every change
Week 4-7:  #4, #3, #2 (refactoring with safety net)
           ‚Üì Zustand first = easier component split
           ‚Üì ESLint catches issues in real-time
           ‚Üì CI/CD validates every commit
Week 8+:   #7, #11, #12 (polish)

Total Time: 8 weeks, no rework
```

**Savings: 1 week + higher quality**

---

## Decision Tree: Should You Deviate?

### When to Skip Issues

**Skip #13 (PropTypes) if:**
- Planning TypeScript migration within 2 months
- TypeScript provides better type safety
- Don&#39;t want temporary solution

**Skip #9 (TODOs) if:**
- Codebase is already clean (few TODOs)
- TODOs are well-organized and tracked

**Skip #10 (Debug Logs) if:**
- Already using proper logger
- Console is already clean

### When to Reorder

**Do #2 (TypeScript) early if:**
- Team already knows TypeScript
- Want type safety during refactoring
- Can migrate quickly (2-3 weeks)

**Do #7 (CSS) early if:**
- CSS is causing immediate problems
- Theme switching broken
- Can&#39;t proceed without CSS fixes

**Do #12 (Bundle Analysis) early if:**
- Performance is critical issue NOW
- Bundle size is already huge (&gt;1MB)
- Users complaining about load times

---

## Concrete Timeline with Milestones

```
Week 1 (Enablers)
‚îú‚îÄ Day 1: #9 TODOs cleanup
‚îú‚îÄ Day 2: #10 Debug logging cleanup
‚îú‚îÄ Day 3-4: #6 Complete ESLint + fix warnings
‚îî‚îÄ Day 5: #8 Environment config
‚úÖ Milestone: Clean codebase, production ESLint, env vars ready

Week 2 (Safety Net)
‚îú‚îÄ Day 1-5: #5 CI/CD pipeline (lint, test, build, deploy stages)
‚îî‚îÄ Parallel: #1 Start unit tests (physics formulas)
‚úÖ Milestone: Auto-validation on every commit

Week 3 (Tests + State)
‚îú‚îÄ Continue: #1 Unit tests (component tests)
‚îî‚îÄ Start: #4 State management (Zustand setup)
‚úÖ Milestone: 30% test coverage, centralized state

Week 4-5 (State + TypeScript)
‚îú‚îÄ Finish: #4 State management (migrate all state)
‚îî‚îÄ Start: #2 TypeScript (utils, constants)
‚úÖ Milestone: No props drilling, types for utilities

Week 6-7 (Components + TypeScript)
‚îú‚îÄ Do: #3 Component refactoring (split 1857 lines ‚Üí 30 files)
‚îî‚îÄ Continue: #2 TypeScript (components)
‚úÖ Milestone: Small focused components, mostly typed

Week 8 (Polish)
‚îú‚îÄ Finish: #2 TypeScript (strict mode)
‚îú‚îÄ Do: #7 CSS modular
‚îî‚îÄ Do: #11 Error boundaries
‚úÖ Milestone: Full type safety, organized CSS, crash protection

Week 9+ (Optimization)
‚îî‚îÄ Do: #12 Bundle analysis + optimization
‚úÖ Milestone: Production-ready, optimized bundle
```

---

## ROI Analysis (Return on Investment)

### High ROI (Do Early)

| Issue | Time | Benefit | ROI |
|-------|------|---------|-----|
| #9 TODOs | 1 day | Clean codebase | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| #10 Debug Logs | 1 day | Clean console | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| #6 ESLint | 2 days | Catches all future issues | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| #8 Env Config | 1-2 days | Enables tests + CI/CD | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| #5 CI/CD | 1 week | Validates everything | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |

**Total: 6 days of work ‚Üí 8 weeks of safety net**

### Medium ROI (Do During Refactor)

| Issue | Time | Benefit | ROI |
|-------|------|---------|-----|
| #1 Tests | 2-3 weeks | Validates refactoring | ‚≠ê‚≠ê‚≠ê‚≠ê |
| #4 State Mgmt | 1-2 weeks | Simplifies components | ‚≠ê‚≠ê‚≠ê‚≠ê |
| #3 Components | 3-4 weeks | Maintainable code | ‚≠ê‚≠ê‚≠ê‚≠ê |
| #2 TypeScript | 4-6 weeks | Type safety | ‚≠ê‚≠ê‚≠ê‚≠ê |

### Low ROI (Do Last)

| Issue | Time | Benefit | ROI |
|-------|------|---------|-----|
| #7 CSS | 2-3 days | Organized styles | ‚≠ê‚≠ê‚≠ê |
| #11 Error Boundaries | 1-2 days | Crash protection | ‚≠ê‚≠ê‚≠ê |
| #12 Bundle Analysis | 1-2 days | Optimization insight | ‚≠ê‚≠ê‚≠ê |
| #13 PropTypes | 1 day | Type checking (temp) | ‚≠ê‚≠ê |

---

## Key Takeaways

### 1. Enablers Before Refactoring
Clean up (TODOs, logs), add ESLint, setup env config BEFORE major refactoring. These make refactoring easier and prevent rework.

### 2. Safety Net Before Changes
CI/CD and tests BEFORE component splitting means every change is validated automatically. Without this, you&#39;re manually testing = slow and error-prone.

### 3. State Before Components
Zustand BEFORE splitting components means you&#39;re splitting simple components (no props drilling) instead of complex ones (19 props).

### 4. Polish After Architecture
CSS, error boundaries, bundle analysis make sense AFTER architecture is stable. Don&#39;t optimize/polish code you&#39;re about to restructure.

### 5. TypeScript in Parallel
TypeScript can run parallel to component refactoring. JS and TS coexist, migrate incrementally, merge when ready.

---

## Summary: The One-Week Foundation

**The most important insight:**

Spending **1 week** on enablers (#9, #10, #6, #8) saves **1-2 weeks** of rework and makes **7 weeks** of refactoring easier.

```
Option A (Priority-based):
Week 1-8: Major refactoring
Week 9: Add ESLint, find 200+ issues in fresh code
Week 10: Rework

Option B (Logic-based):
Week 1: Enablers (ESLint, cleanup, env config)
Week 2-8: Major refactoring (ESLint catches issues in real-time)
Week 9: Polish
(No rework needed)
```

**The 1-week foundation:**
1. Clean codebase (#9, #10)
2. Production ESLint (#6)
3. Environment config (#8)
4. CI/CD pipeline (#5)

**Result:** Everything after this is easier, faster, and higher quality.

---

## ü§ù HANDOFF FOR NEXT AI (Phase 2 Ready)

**Date: 2026-02-04**  
**Status: Phase 0 + Phase 1 Complete, Phase 2 Ready**

### What&#39;s Done
- Codebase is clean (no debug logs, minimal TODOs)
- ESLint is production-grade (v9 flat config)
- Environment config is centralized (src/config/env.js)
- CI/CD validates every push (lint, test, build, lighthouse, sonarcloud)
- Database of physics tests = 77 passing (formulas + integration)
- Physics sandbox is scientifically rigorous and grounded in Wikipedia-verified formulas

### What&#39;s Next
**Start with Phase 2 - Architecture (Weeks 4-7):**

1. **Week 4-5: #4 State Management**
   - Tool: Zustand (install + setup)
   - Files: Create src/hooks/stores/ directory
   - Work: Migrate App.jsx props (19 prop parameters) to centralized stores
   - Goal: No props drilling, self-contained components
   - Validation: CI/CD auto-validates every store migration commit

2. **Week 5-7: #3 Component Refactoring**
   - Target: Split GameScene.jsx (1857 lines) into 30 focused components
   - Process: Extract hooks first (usePhysics, useDragging, etc.), then split rendering
   - Validation: Tests + ESLint catch circular deps in real-time
   - Result: Components &lt;200 lines each

3. **Week 4-10 (Parallel): #2 TypeScript**
   - Order: Utils/physics ‚Üí constants ‚Üí components
   - Approach: Incremental (JS and TS coexist)
   - Validation: CI/CD auto-validates TypeScript compilation

### Critical Notes for Next AI
- ‚úÖ All enablers in place (don&#39;t redo Phase 0)
- ‚úÖ Safety net ready (CI/CD validates every commit)
- ‚úÖ Tests cover physics formulas (use them for regression testing)
- ‚úÖ ESLint catches 80% of AI coding mistakes (circular deps, long functions, unused vars)
- ‚úÖ Environment config is centralized (use APP_ENV throughout)

### Key Dependencies
- #4 MUST come before #3 (reduce props ‚Üí easier component split)
- #6 ESLint MUST run during #3 (catches circular dependencies)
- #5 CI/CD MUST validate all commits in #2, #3, #4 (no manual testing)
- #1 Tests MUST validate behavior during #3 (ensure refactoring doesn&#39;t break physics)

### No Action Required by Next AI
- DON&#39;T re-check phases 0-1 (already verified clean)
- DON&#39;T re-run ESLint setup (already production-grade)
- DON&#39;T re-check unit tests (77 passing, locked in place)

**Just start Phase 2. Everything else is done.**

---

**Status:** Ready for implementation  
**Next Action:** Start Phase 2 (#4 State Management)  
**Expected Completion:** 8-9 weeks total from now (4-5 weeks Phase 2 + 3-4 weeks Phase 3 polish)
</code></pre>
        </details>
      </section>
    
        </article>
      </main>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
  <script>
    // Lazy-load Kekule only when molecule viewer is expanded (saves bandwidth on low-end devices)
    (() => {
      let smilesDrawerLoaded = false
      let smilesDrawerLoading = false
      
      // Convert explicit SMILES like [CH3][CH](OH)[CH3] to standard like CC(O)C
      const explicitToStandard = (smiles) => {
        return smiles
          // Common organic groups - order matters (longer patterns first)
          .replace(/\[CH3\]/g, 'C')
          .replace(/\[CH2\]/g, 'C')
          .replace(/\[CH\]/g, 'C')
          .replace(/\[OH\]/g, 'O')
          .replace(/\[NH2\]/g, 'N')
          .replace(/\[NH\]/g, 'N')
          .replace(/\[SH\]/g, 'S')
          // Single atoms in brackets (keep aromatic lowercase)
          .replace(/\[C\]/g, 'C')
          .replace(/\[N\]/g, 'N')
          .replace(/\[O\]/g, 'O')
          .replace(/\[S\]/g, 'S')
          .replace(/\[P\]/g, 'P')
          .replace(/\[F\]/g, 'F')
          .replace(/\[Cl\]/g, 'Cl')
          .replace(/\[Br\]/g, 'Br')
          .replace(/\[I\]/g, 'I')
          // Bare atoms in branches - H is implicit in standard SMILES
          .replace(/\(OH\)/g, '(O)')
          .replace(/\(NH2\)/g, '(N)')
          .replace(/\(NH\)/g, '(N)')
          .replace(/\(SH\)/g, '(S)')
      }
      
      const loadSmilesDrawer = async () => {
        if (smilesDrawerLoaded) return
        if (smilesDrawerLoading) {
          return new Promise(resolve => {
            const check = setInterval(() => {
              if (smilesDrawerLoaded) { clearInterval(check); resolve() }
            }, 50)
          })
        }
        smilesDrawerLoading = true
        
        // Load SmilesDrawer from CDN (much simpler than Kekule)
        await new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = 'https://unpkg.com/smiles-drawer@2.1.7/dist/smiles-drawer.min.js'
          script.onload = resolve
          script.onerror = reject
          document.body.appendChild(script)
        })
        
        smilesDrawerLoaded = true
        smilesDrawerLoading = false
      }
      
      const initMolecule = async (node) => {
        if (node.dataset.initialized) return
        node.dataset.initialized = 'true'
        
        const rawSmiles = node.getAttribute('data-smiles')
        if (!rawSmiles) return
        
        // Convert explicit format to standard if needed
        const smiles = explicitToStandard(rawSmiles)
        
        try {
          await loadSmilesDrawer()
          
          const drawer = new SmilesDrawer.SvgDrawer({ 
            width: 300, 
            height: 200,
            explicitHydrogens: true,
            terminalCarbons: true,
            compactDrawing: false
          })
          
          console.log('Parsing SMILES:', rawSmiles, '->', smiles)
          SmilesDrawer.parse(smiles, (tree) => {
            console.log('Parse success, tree:', tree)
            const svgElement = drawer.draw(tree, null, 'light')
            console.log('SVG element:', svgElement)
            node.innerHTML = ''
            node.appendChild(svgElement)
          }, (err) => {
            console.error('SMILES parse error for "' + smiles + '":', err)
            node.innerHTML = '<code>' + rawSmiles + '</code>'
          })
        } catch (err) {
          console.error('SmilesDrawer load error:', err)
          node.innerHTML = '<code>' + smiles + '</code>'
        }
      }
      
      // Use IntersectionObserver for lazy loading when scrolled into view
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initMolecule(entry.target)
            observer.unobserve(entry.target)
          }
        })
      }, { rootMargin: '100px' })
      
      // Also handle <details> expansion for molecules inside collapsed sections
      document.addEventListener('toggle', (e) => {
        if (e.target.tagName === 'DETAILS' && e.target.open) {
          const molecules = e.target.querySelectorAll('[data-smiles]:not([data-initialized])')
          molecules.forEach(node => initMolecule(node))
        }
      }, true)
      
      // Observe all molecule nodes
      const init = () => {
        const nodes = document.querySelectorAll('[data-smiles]')
        nodes.forEach(node => observer.observe(node))
      }
      
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init)
      } else {
        init()
      }
    })()
  </script>
</body>
</html>