<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ISSUE_04_NO_STATE_MANAGEMENT.md - Boiling Water Wiki</title>
  <link rel="stylesheet" href="/wiki/assets/styles.css" />
  <!-- Kekule CSS loaded lazily when molecule viewer is needed -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />
</head>
<body>
  <div class="wiki-layout">
    <div class="wiki-main">
      <header class="wiki-topbar">
        <details class="wiki-menu" aria-label="Menu">
          <summary>‚ò∞ Menu</summary>
          <nav class="wiki-menu-links">
            <div class="menu-section">
              <div class="menu-heading">Main</div>
              <a href="/wiki/index.html">üìö Main page</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Science</div>
              <a href="/wiki/entities/elements/index.html">‚öõÔ∏è Elements</a>
              <a href="/wiki/entities/compounds/index.html">üß™ Compounds</a>
              <a href="/wiki/entities/solutions/index.html">üíß Solutions</a>
              <a href="/wiki/entities/phases/index.html">‚ùÑÔ∏è Phases</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Game Structure</div>
              <a href="/wiki/entities/levels/index.html">üìä Levels</a>
              <a href="/wiki/entities/experiments/index.html">üî¨ Experiments</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Code Reference</div>
              <a href="/wiki/entities/formulas/index.html">üìê Formulas</a>
              <a href="/wiki/entities/processes/index.html">‚öôÔ∏è Processes</a>
              <a href="/wiki/entities/modules/index.html">üì¶ Modules</a>
              <a href="/wiki/entities/symbols/index.html">üî£ Symbols</a>
              <a href="/wiki/entities/public/index.html">üìÅ Public Files</a>
              <a href="/wiki/entities/assets/index.html">üñºÔ∏è Assets</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Repository</div>
              <a href="/wiki/entities/docs/index.html">üìñ Docs</a>
              <a href="/wiki/entities/scripts/index.html">üß∞ Scripts</a>
              <a href="/wiki/entities/styles/index.html">üé® Styles</a>
              <a href="/wiki/entities/root-files/index.html">üóÇÔ∏è Root Files</a>
            </div>
            <div class="wiki-menu-divider"></div>
            <a href="/">‚¨ÖÔ∏è Back to Game</a>
          </nav>
        </details>
        
        <nav class="breadcrumbs" aria-label="Breadcrumb">
          <a href="/wiki/../../../index.html">Main</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../index.html">Modules</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../docs/index.html">docs</a> <span class="breadcrumb-sep">‚Ä∫</span> <a href="/wiki/../docs/audit/index.html">audit</a> <span class="breadcrumb-sep">‚Ä∫</span> <span>ISSUE_04_NO_STATE_MANAGEMENT.md</span>
        </nav>
        <div class="wiki-topbar-title">ISSUE_04_NO_STATE_MANAGEMENT.md</div>
      </header>
      <main class="wiki-content">
        
        <article class="wiki-article">
          
      
    <aside class="infobox">
      <div class="infobox-title">ISSUE_04_NO_STATE_MANAGEMENT.md</div>
      
      <div class="infobox-row">
        <div class="infobox-label">Type</div>
        <div class="infobox-value">Module</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">File type</div>
        <div class="infobox-value">md</div>
      </div>
    
    </aside>
  
      <section class="section">
        
  <div class="entity-header">
    <h1>ISSUE_04_NO_STATE_MANAGEMENT.md</h1>
    <p class="subtitle">Module</p>
  </div>

      </section>
      
      <section class="section" id="source-file">
        <h2>Source file</h2>
        <p><code>docs\audit\ISSUE_04_NO_STATE_MANAGEMENT.md</code></p>
        <details>
          <summary>View source code</summary>
          <pre class="line-numbers"><code class="language-markdown"># Issue #4: No Centralized State Management

**Severity:** üü° High  
**Status:** ‚ùå Props Drilling  
**Priority:** P1  
**Effort:** 1-2 weeks

---

## What It Means

State is scattered everywhere and passed down through **props drilling** ‚Äî passing props through multiple component levels even though intermediate components don&#39;t use them.

```javascript
// Current structure (props drilling):
App
  ‚îú‚îÄ has: userLocation, activeWorkshop, activeLevel, ...
  ‚îÇ
  ‚îî‚îÄ GameScene (receives 11+ props just to pass them down)
      ‚îú‚îÄ has: location, workshopLayout, burnerConfig, ...
      ‚îÇ
      ‚îú‚îÄ ControlPanel (receives 5 props just to pass them down)
      ‚îÇ   ‚îÇ
      ‚îÇ   ‚îî‚îÄ BurnerControls (finally uses onBurnerChange)
      ‚îÇ
      ‚îú‚îÄ LocationPopup (receives location just to use it)
      ‚îÇ
      ‚îî‚îÄ BoilingPopup (receives stats just to display them)

// Needed properties:
location                    // Needed in GameScene AND LocationPopup
workshopLayout              // Needed in GameScene AND Pot AND Burner
burnerConfig                // Needed in GameScene AND ControlPanel AND BurnerControls
roomConfig                  // Needed in GameScene AND RoomControls
onLocationChange            // Needed in GameScene AND LocationPopup
onBurnerChange              // Needed in GameScene AND ControlPanel AND BurnerControls
// ... 10+ more props
```

**With centralized state:**
```javascript
// ‚úÖ Components get what they need directly
function LocationPopup() {
  const { location, setLocation } = useGameState()  // Gets it directly
  return &lt;input value={location.name} onChange={setLocation} /&gt;
}

function BurnerControls() {
  const { burnerConfig, setBurnerHeat } = useGameState()  // Gets it directly
  return &lt;button onClick={() =&gt; setBurnerHeat(2)}&gt;High&lt;/button&gt;
}
```

---

## Why It&#39;s Critical

### Problem 1: Prop Callbacks Become Unmanageable

**Current GameScene Props (19 total):**

```jsx
&lt;GameScene 
  // Data props (8)
  stage={stage}
  location={userLocation}
  workshopLayout={activeWorkshopData?.layout}
  workshopImages={activeWorkshopData?.images}
  workshopEffects={activeWorkshopData?.effects}
  burnerConfig={activeWorkshopData?.burnerConfig}
  roomConfig={activeWorkshopData?.room}
  acUnitConfig={activeWorkshopData?.acUnit}
  
  // Callback props (11)
  onStageChange={handleStageChange}
  onWaterBoiled={handleWaterBoiled}
  onSkipTutorial={handleSkipTutorial}
  onLevelChange={handleLevelChange}
  onExperimentChange={handleExperimentChange}
  hasBoiledBefore={hasBoiledBefore}
  onLocationChange={handleLocationChange}
  onEquipmentChange={handleEquipmentChange}
  // ... more props
/&gt;
```

**Adding a new feature means:**
1. Create setter in App.jsx
2. Pass it to GameScene props
3. GameScene passes it to ControlPanel
4. ControlPanel passes it to BurnerControls
5. BurnerControls finally calls it

**Change one thing? Must update 5 files.**

### Problem 2: State Synchronization Bugs

Different parts of the app can have conflicting state:

```javascript
// App.jsx
const [activeFluid, setActiveFluid] = useState(&#39;water&#39;)

// GameScene.jsx
const [activeFluid, setActiveFluid] = useState(&#39;water&#39;)

// Now they&#39;re out of sync:
// User selects ethanol in App ‚Üí updates App state
// GameScene is still showing water properties
// Physics calculations use wrong fluid

// To fix: Must pass activeFluid as prop
// But then GameScene can&#39;t set it without a callback
// Callbacks get buried in props drilling hell
```

### Problem 3: Testing is Fragile

To test one small component, you must mock the entire prop chain:

```javascript
// To test LocationPopup:
import LocationPopup from &#39;./LocationPopup&#39;

describe(&#39;LocationPopup&#39;, () =&gt; {
  it(&#39;should update location when user enters city&#39;, () =&gt; {
    const mockOnLocationChange = jest.fn()
    
    const { getByPlaceholder } = render(
      &lt;LocationPopup 
        location={{ altitude: 0, name: &#39;Sea Level&#39; }}
        onLocationChange={mockOnLocationChange}
        workshopLayout={mockLayout}
        burnerConfig={mockBurner}
        roomConfig={mockRoom}
        // ... 10 more props that LocationPopup doesn&#39;t even use!
      /&gt;
    )
    
    fireEvent.change(getByPlaceholder(&#39;City&#39;), { target: { value: &#39;Denver&#39; } })
    expect(mockOnLocationChange).toHaveBeenCalled()
  })
})
```

**With centralized state:**
```javascript
describe(&#39;LocationPopup&#39;, () =&gt; {
  it(&#39;should update location when user enters city&#39;, () =&gt; {
    const { getByPlaceholder } = render(
      &lt;GameStateProvider initialState={{ location: { name: &#39;Sea Level&#39; } }}&gt;
        &lt;LocationPopup /&gt;
      &lt;/GameStateProvider&gt;
    )
    
    fireEvent.change(getByPlaceholder(&#39;City&#39;), { target: { value: &#39;Denver&#39; } })
    // LocationPopup gets location from context directly ‚úÖ
  })
})
```

### Problem 4: Accidental Props Passed to DOM

```javascript
// In your current code, if you accidentally pass unknown props:
&lt;GameScene unknownProp={value} /&gt;

// React silently ignores it (or passes it to DOM)
// Hard to debug why feature doesn&#39;t work
// Without types, you don&#39;t know which props are valid
```

---

## Current State: Chaotic Props Drilling

### App.jsx State (What gets passed down)

```javascript
// src/App.jsx

function App() {
  // User/location state
  const [userLocation, setUserLocation] = useState(null)
  
  // UI state
  const [gameStage, setGameStage] = useState(0)
  const [activeView, setActiveView] = useState(&#39;game&#39;)
  const [gameInstanceKey, setGameInstanceKey] = useState(0)
  
  // Level/experiment state
  const [activeLevel, setActiveLevel] = useState(1)
  const [activeExperiment, setActiveExperiment] = useState(&#39;boiling-water&#39;)
  const [activeWorkshopId, setActiveWorkshopId] = useState(&#39;pre-alpha-kitchen-1&#39;)
  const [availableWorkshops, setAvailableWorkshops] = useState([])
  const [activeWorkshopData, setActiveWorkshopData] = useState(null)
  
  // Tutorial state
  const [hasBoiledBefore, setHasBoiledBefore] = useState(false)
  const [showSelectors, setShowSelectors] = useState(false)
  
  // All passed as props to GameScene ‚Üì
  return (
    &lt;GameScene 
      stage={gameStage}
      location={userLocation}
      workshopLayout={activeWorkshopData?.layout}
      workshopImages={activeWorkshopData?.images}
      // ... 11 more props
    /&gt;
  )
}
```

### Cascade of Props Through Components

```
App
  ‚îú‚îÄ state: userLocation, gameStage, activeLevel, activeExperiment, activeWorkshop, ...
  ‚îÇ
  ‚îî‚îÄ GameScene
      ‚îú‚îÄ receives: 19 props
      ‚îú‚îÄ uses: 5 directly
      ‚îú‚îÄ passes down: 14 to child components
      ‚îÇ
      ‚îú‚îÄ ControlPanel
      ‚îÇ   ‚îú‚îÄ receives: 8 props
      ‚îÇ   ‚îú‚îÄ uses: 2 directly
      ‚îÇ   ‚îú‚îÄ passes down: 6 to children
      ‚îÇ   ‚îÇ
      ‚îÇ   ‚îî‚îÄ BurnerControls
      ‚îÇ       ‚îú‚îÄ receives: 4 props
      ‚îÇ       ‚îî‚îÄ uses: 1 (burnerConfig, onBurnerChange)
      ‚îÇ
      ‚îú‚îÄ LocationPopup
      ‚îÇ   ‚îú‚îÄ receives: 5 props (location, onLocationChange, ...)
      ‚îÇ   ‚îî‚îÄ uses: 2
      ‚îÇ
      ‚îî‚îÄ RoomControls
          ‚îú‚îÄ receives: 3 props
          ‚îî‚îÄ uses: 3
```

**Chain Length: 2-3 levels**

With each level, prop lists grow and component responsibilities become unclear.

---

## Real-World Bugs Without Centralized State

### Bug #1: Prop Update Doesn&#39;t Propagate

```javascript
// User changes location in App.jsx
setUserLocation({ altitude: 5000, name: &#39;Denver&#39; })

// But GameScene was rendered with OLD location prop
// and doesn&#39;t re-render because... something else happened

// Meanwhile:
// - Physics calculations use old altitude
// - Display shows old location
// - Room environment has wrong pressure

// Hours spent debugging: &quot;Why did location change not work?&quot;
```

### Bug #2: Callback Passed Incorrectly

```javascript
// App.jsx
const handleLocationChange = (newLocation) =&gt; {
  setUserLocation(newLocation)
  setGameStage(0)  // Reset game
}

// Passed to GameScene
&lt;GameScene onLocationChange={handleLocationChange} /&gt;

// GameScene passes it to LocationPopup
&lt;LocationPopup onLocationChange={onLocationChange} /&gt;

// But if LocationPopup is deeply nested:
// GameScene ‚Üí Modal ‚Üí Form ‚Üí LocationInput

// If you pass it through 5 levels and miss one level,
// it silently fails. No error, just doesn&#39;t work.
// How do you find this bug? Read the entire prop chain.
```

### Bug #3: Stale Closures in Callbacks

```javascript
// GameScene.jsx
const handleEquipmentChange = (type, id) =&gt; {
  // This closes over current value of activeWorkshop
  const updatedWorkshop = await loadEquipment(activeWorkshopId, type, id)
  setActiveWorkshopData(updatedWorkshop)
}

// But if activeWorkshopId changed elsewhere and didn&#39;t update prop,
// this callback uses STALE value
// User switches workshop, then tries to change burner ‚Üí loads from wrong workshop

// With centralized state, no stale closures:
const handleEquipmentChange = (type, id) =&gt; {
  const { activeWorkshopId } = useGameState()  // Always current
  const updatedWorkshop = await loadEquipment(activeWorkshopId, type, id)
  setActiveWorkshopData(updatedWorkshop)
}
```

### Bug #4: Props Change Mid-Render

```javascript
// Component renders with old props mid-effect
useEffect(() =&gt; {
  if (location.altitude !== prevAltitude) {
    // Recalculate boiling point
    const bp = calculateBoilingPoint(location.altitude, fluidProps)
    // But what if location changed during calculation?
    // Now bp is based on DIFFERENT altitude than what&#39;s displayed
  }
}, [location, fluidProps])

// With centralized state, single source of truth:
const { location, fluidProps } = useGameState()  // Guaranteed consistent
```

---

## Solution Options

### Option 1: React Context API (Simplest, Free)

**Pros:**
- No dependencies needed
- Built into React
- Good for small-medium projects
- Works with TypeScript

**Cons:**
- Performance issues if context updates frequently
- Requires Provider wrapper
- Manual optimization needed (useMemo, useCallback)
- More boilerplate

```typescript
// src/context/GameStateContext.tsx

interface GameState {
  location: Location
  activeLevel: number
  activeExperiment: string
  activeWorkshop: WorkshopData
  gameStage: GameStage
  hasBoiledBefore: boolean
  showSelectors: boolean
}

interface GameContextValue extends GameState {
  setLocation: (location: Location) =&gt; void
  setActiveLevel: (level: number) =&gt; void
  setActiveExperiment: (exp: string) =&gt; void
  setGameStage: (stage: GameStage) =&gt; void
  // ... more setters
}

const GameContext = createContext&lt;GameContextValue | null&gt;(null)

export function GameStateProvider({ children }) {
  const [state, setState] = useState&lt;GameState&gt;({ /* ... */ })
  
  const value: GameContextValue = {
    ...state,
    setLocation: (location) =&gt; setState(prev =&gt; ({ ...prev, location })),
    setActiveLevel: (level) =&gt; setState(prev =&gt; ({ ...prev, activeLevel: level })),
    // ... more setters
  }
  
  return (
    &lt;GameContext.Provider value={value}&gt;
      {children}
    &lt;/GameContext.Provider&gt;
  )
}

export function useGameState() {
  const context = useContext(GameContext)
  if (!context) throw new Error(&#39;useGameState must be within GameStateProvider&#39;)
  return context
}
```

**Usage:**
```typescript
// In any component, anywhere
function LocationPopup() {
  const { location, setLocation } = useGameState()
  
  return (
    &lt;input 
      value={location.name}
      onChange={(e) =&gt; setLocation({ ...location, name: e.target.value })}
    /&gt;
  )
}
```

**Cost: 1 week** (set up, migrate state, test)

---

### Option 2: Zustand (Recommended, Lightweight)

**Pros:**
- Extremely simple API
- No Provider wrapper needed
- Excellent TypeScript support
- Great performance
- Small bundle size
- Works outside React (good for physics engine)

**Cons:**
- One more dependency
- DevTools setup required
- Less ecosystem than Redux

```typescript
// src/store/gameStore.ts

import { create } from &#39;zustand&#39;

interface GameStore {
  // State
  location: Location
  activeLevel: number
  activeExperiment: string
  activeWorkshop: WorkshopData
  gameStage: GameStage
  hasBoiledBefore: boolean
  
  // Actions
  setLocation: (location: Location) =&gt; void
  setActiveLevel: (level: number) =&gt; void
  setActiveExperiment: (exp: string) =&gt; void
  setGameStage: (stage: GameStage) =&gt; void
}

export const useGameStore = create&lt;GameStore&gt;((set) =&gt; ({
  // State
  location: null,
  activeLevel: 1,
  activeExperiment: &#39;boiling-water&#39;,
  activeWorkshop: null,
  gameStage: 0,
  hasBoiledBefore: false,
  
  // Actions
  setLocation: (location) =&gt; set({ location }),
  setActiveLevel: (level) =&gt; set({ activeLevel: level }),
  setActiveExperiment: (exp) =&gt; set({ activeExperiment: exp }),
  setGameStage: (stage) =&gt; set({ gameStage: stage }),
  // ... more actions
}))
```

**Usage:**
```typescript
// Anywhere, no Provider needed
function LocationPopup() {
  const { location, setLocation } = useGameStore()
  
  return (
    &lt;input 
      value={location.name}
      onChange={(e) =&gt; setLocation({ ...location, name: e.target.value })}
    /&gt;
  )
}

// In physics code (outside React):
const altitude = useGameStore.getState().location.altitude
const boilingPoint = calculateBoilingPoint(altitude, fluidProps)
```

**Cost: 3-5 days** (simpler setup than Context)

---

### Option 3: Redux (Overkill for This Project)

**Pros:**
- Excellent DevTools
- Time-travel debugging
- Large ecosystem
- Good for huge apps

**Cons:**
- Massive boilerplate
- Steep learning curve
- Overkill for physics game
- Bundle size hit

**Not recommended** for Boiling Water (too simple for Redux complexity)

---

## Recommended: Zustand + Context Hybrid

Use **Zustand for global state** + **React Context for feature-specific state**:

```typescript
// Global state (shared across app)
// src/store/gameStore.ts
export const useGameStore = create&lt;GameStore&gt;((set) =&gt; ({
  location: null,
  activeLevel: 1,
  activeExperiment: &#39;boiling-water&#39;,
  activeWorkshop: null,
  gameStage: 0,
  setLocation: (location) =&gt; set({ location }),
  setActiveLevel: (level) =&gt; set({ activeLevel: level }),
  // ... etc
}))

// Feature-specific state (just for gameplay)
// src/context/GameSceneContext.tsx
interface GameSceneState {
  waterInPot: number
  temperature: number
  isBoiling: boolean
  potPosition: Position
  // ... gameplay-specific state
}

export const GameSceneProvider = ({ children }) =&gt; {
  const [state, setState] = useState&lt;GameSceneState&gt;({...})
  // Only GameScene and its children use this
  return &lt;GameSceneContext.Provider value={state}&gt;{children}&lt;/GameSceneContext.Provider&gt;
}
```

**Benefits:**
- ‚úÖ Global state easy to access (Zustand)
- ‚úÖ Gameplay state isolated (Context)
- ‚úÖ No prop drilling
- ‚úÖ Clean separation of concerns

---

## Implementation Plan

### Step 1: Install Zustand (1 day)

```bash
npm install zustand
npm install --save-dev @types/zustand
```

### Step 2: Create Store (2 days)

```typescript
// src/store/gameStore.ts

import { create } from &#39;zustand&#39;
import { Location, WorkshopData, GameStage } from &#39;../types&#39;

interface GameStore {
  // Location &amp; Altitude
  location: Location | null
  setLocation: (location: Location) =&gt; void
  
  // Level/Experiment
  activeLevel: number
  setActiveLevel: (level: number) =&gt; void
  
  activeExperiment: string
  setActiveExperiment: (exp: string) =&gt; void
  
  // Workshop
  activeWorkshopId: string
  setActiveWorkshopId: (id: string) =&gt; void
  
  activeWorkshopData: WorkshopData | null
  setActiveWorkshopData: (data: WorkshopData) =&gt; void
  
  // UI
  gameStage: GameStage
  setGameStage: (stage: GameStage) =&gt; void
  
  // Tutorial
  hasBoiledBefore: boolean
  setHasBoiledBefore: (value: boolean) =&gt; void
  
  showSelectors: boolean
  setShowSelectors: (value: boolean) =&gt; void
  
  // Equipment
  activeBurner: string
  setActiveBurner: (burner: string) =&gt; void
}

export const useGameStore = create&lt;GameStore&gt;((set) =&gt; ({
  location: null,
  setLocation: (location) =&gt; set({ location }),
  
  activeLevel: 1,
  setActiveLevel: (level) =&gt; set({ activeLevel: level }),
  
  activeExperiment: &#39;boiling-water&#39;,
  setActiveExperiment: (exp) =&gt; set({ activeExperiment: exp }),
  
  activeWorkshopId: &#39;pre-alpha-kitchen-1&#39;,
  setActiveWorkshopId: (id) =&gt; set({ activeWorkshopId: id }),
  
  activeWorkshopData: null,
  setActiveWorkshopData: (data) =&gt; set({ activeWorkshopData: data }),
  
  gameStage: 0,
  setGameStage: (stage) =&gt; set({ gameStage: stage }),
  
  hasBoiledBefore: false,
  setHasBoiledBefore: (value) =&gt; set({ hasBoiledBefore: value }),
  
  showSelectors: false,
  setShowSelectors: (value) =&gt; set({ showSelectors: value }),
  
  activeBurner: &#39;basic-2000w&#39;,
  setActiveBurner: (burner) =&gt; set({ activeBurner: burner }),
}))
```

### Step 3: Update App.jsx (2 days)

**Before:**
```javascript
function App() {
  const [userLocation, setUserLocation] = useState(null)
  const [activeLevel, setActiveLevel] = useState(1)
  const [activeExperiment, setActiveExperiment] = useState(&#39;boiling-water&#39;)
  // ... 10 more pieces of state
  
  const handleLocationChange = (location) =&gt; setUserLocation(location)
  const handleLevelChange = (level) =&gt; setActiveLevel(level)
  // ... 10 more handlers
  
  return (
    &lt;GameScene
      location={userLocation}
      activeLevel={activeLevel}
      activeExperiment={activeExperiment}
      onLocationChange={handleLocationChange}
      onLevelChange={handleLevelChange}
      // ... 15 more props
    /&gt;
  )
}
```

**After:**
```typescript
function App() {
  // No local state! Get everything from Zustand
  return (
    &lt;GameScene /&gt;
  )
}
```

### Step 4: Update GameScene (2 days)

**Before:**
```javascript
function GameScene({ 
  stage, location, activeLevel, activeExperiment,
  onLocationChange, onLevelChange, onExperimentChange,
  // ... 13 more props
}) {
  // 50+ useState hooks
}
```

**After:**
```typescript
function GameScene() {
  const { 
    gameStage, 
    location, 
    activeLevel, 
    activeExperiment,
    setLocation,
    setActiveLevel,
    setActiveExperiment,
    setGameStage,
  } = useGameStore()
  
  // Get state directly, no props needed!
  // Physics-specific state still in local useState
  const [waterInPot, setWaterInPot] = useState(0)
  const [temperature, setTemperature] = useState(...)
  // ... gameplay state only (20 instead of 50+ pieces of state)
}
```

### Step 5: Update Child Components (3-4 days)

**Before:**
```javascript
// ControlPanel receives 5 props just to pass down
function ControlPanel({ burnerConfig, onBurnerChange, roomConfig, ... }) {
  return &lt;BurnerControls burnerConfig={burnerConfig} onBurnerChange={onBurnerChange} /&gt;
}

// BurnerControls finally uses the props
function BurnerControls({ burnerConfig, onBurnerChange }) {
  return &lt;button onClick={() =&gt; onBurnerChange(2)}&gt;High&lt;/button&gt;
}
```

**After:**
```typescript
// ControlPanel doesn&#39;t receive any props
function ControlPanel() {
  return &lt;BurnerControls /&gt;
}

// BurnerControls gets what it needs directly
function BurnerControls() {
  const { activeBurner, setActiveBurner } = useGameStore()
  
  return &lt;button onClick={() =&gt; setActiveBurner(&#39;pro-5000w&#39;)}&gt;High&lt;/button&gt;
}
```

### Step 6: Test &amp; Verify (2 days)

```bash
npm run dev
npm run build
npm run lint
```

**Cost: 1-2 weeks total** (much less than refactoring components)

---

## Before and After: Concrete Example

### Current: Add New Feature &quot;Experiment History&quot;

To track user&#39;s past boiling temperatures:

**Step 1: Create setter in App.jsx**
```javascript
const [experimentHistory, setExperimentHistory] = useState([])
```

**Step 2: Pass to GameScene**
```javascript
&lt;GameScene experimentHistory={experimentHistory} /&gt;
```

**Step 3: GameScene passes to BoilingPopup**
```javascript
&lt;BoilingPopup experimentHistory={experimentHistory} onAddHistory={handleAddHistory} /&gt;
```

**Step 4: Create handler in App.jsx**
```javascript
const handleAddHistory = (result) =&gt; {
  setExperimentHistory([...experimentHistory, result])
}
```

**Step 5: Pass handler to BoilingPopup**
```javascript
&lt;BoilingPopup onAddHistory={handleAddHistory} /&gt;
```

**Files modified: 4** (App.jsx, GameScene.jsx, BoilingPopup.jsx, + type definitions)

### With Zustand: Add Same Feature

**Step 1: Add to store**
```typescript
// src/store/gameStore.ts
experimentHistory: [],
addToHistory: (result) =&gt; set((state) =&gt; ({
  experimentHistory: [...state.experimentHistory, result]
}))
```

**Step 2: Use in BoilingPopup**
```typescript
function BoilingPopup() {
  const { addToHistory } = useGameStore()
  
  const handleFinish = () =&gt; {
    addToHistory({ temperature: 100, boilTime: 300 })
  }
  
  return &lt;button onClick={handleFinish}&gt;Finish&lt;/button&gt;
}
```

**Files modified: 2** (store, component that uses it)  
**Complexity: 50% less**  
**Time: 30 minutes vs 2-3 hours**

---

## Testing: Before vs After

### Current (Props Drilling)

```javascript
// To test BoilingPopup with history feature:
describe(&#39;BoilingPopup&#39;, () =&gt; {
  it(&#39;should add boil result to history&#39;, () =&gt; {
    const mockHistory = []
    const mockAddToHistory = jest.fn()
    
    const { getByText } = render(
      &lt;BoilingPopup
        experimentHistory={mockHistory}
        onAddToHistory={mockAddToHistory}
        // ... 5 more props
      /&gt;
    )
    
    fireEvent.click(getByText(&#39;Finish&#39;))
    expect(mockAddToHistory).toHaveBeenCalledWith(expect.objectContaining({
      temperature: 100
    }))
  })
})
```

### With Zustand

```typescript
describe(&#39;BoilingPopup&#39;, () =&gt; {
  it(&#39;should add boil result to history&#39;, () =&gt; {
    const { result } = renderHook(() =&gt; useGameStore())
    
    const { getByText } = render(
      &lt;BoilingPopup /&gt;
    )
    
    fireEvent.click(getByText(&#39;Finish&#39;))
    
    expect(result.current.experimentHistory).toContainEqual(
      expect.objectContaining({ temperature: 100 })
    )
  })
})
```

**No mock props needed.** Test is cleaner and more realistic.

---

## Performance Considerations

### Context API (without optimization)

‚ö†Ô∏è **Problem:** Every state change re-renders all consumers

```javascript
// Any update in context causes ALL consumers to re-render
const [location, setLocation] = useState(null)  // ‚Üê Change this
const [temperature, setTemperature] = useState(0)
const [isBoiling, setIsBoiling] = useState(false)

// ALL context consumers re-render, even if they only use temperature
// Physics runs every 100ms ‚Üí 600 re-renders per minute!
```

‚úÖ **Solution:** Split contexts by concern

```javascript
// Separate contexts for different concerns
const LocationContext = createContext()      // Changes rarely
const PhysicsContext = createContext()       // Changes frequently (100ms)

// Components only subscribe to what they need
```

### Zustand (optimized by default)

‚úÖ **Good:** Built-in optimization

```typescript
// Zustand automatically optimizes subscriptions
const waterInPot = useGameStore((state) =&gt; state.waterInPot)

// Only re-renders if waterInPot changes, even if other state changes
// Physics runs every 100ms ‚Üí ZERO unnecessary re-renders ‚úÖ
```

**Zustand is better for physics-heavy apps.**

---

## Success Metrics

| Metric | Before | After |
|--------|--------|-------|
| Props passed to GameScene | 19 | 0 |
| Prop levels (max) | 3-4 | 1 (direct access) |
| Files to modify for new feature | 4-5 | 1-2 |
| Testing boilerplate | High | Low |
| Time to add feature | 2-4 hours | 30 min |
| Performance (re-renders per physics step) | 5-10 | 1-2 |

---

## Cost-Benefit Analysis

| Item | Cost | Benefit |
|------|------|---------|
| Setup Zustand | 1 day | Lifetime productivity boost |
| Migrate state | 3 days | No more prop drilling |
| Update GameScene | 2 days | Cleaner code, easier testing |
| Update components | 3 days | Reusable, testable pieces |
| Overhead | 9 days | 5√ó faster feature development |

**ROI: Pays for itself after 2-3 new features**

---

## Implementation Timeline

| Phase | Duration | Effort |
|-------|----------|--------|
| 1. Install &amp; create store | 1 day | Easy |
| 2. Migrate App state | 1 day | Easy |
| 3. Update GameScene | 2 days | Medium |
| 4. Update child components | 3 days | Medium |
| 5. Test &amp; verify | 2 days | Medium |
| **Total** | **9 days** | **1-2 weeks** |

---

## Recommended Approach

1. **Week 1:**
   - Install Zustand
   - Create game store with all global state
   - Update App.jsx to remove useState hooks
   - Update GameScene to use store

2. **Week 2:**
   - Update ControlPanel and sub-components
   - Update LocationPopup
   - Update BoilingPopup
   - Test everything

3. **Ongoing:**
   - New features are now 2-3√ó faster to add
   - Components are reusable across experiments
   - Testing is straightforward

---

## Related Issues

- [Issue #3: Massive Components](ISSUE_03_MASSIVE_COMPONENTS.md) (props drilling is symptom)
- [Issue #1: No Unit Tests](ISSUE_01_NO_UNIT_TESTS.md) (state management makes tests easier)
- [Issue #2: No TypeScript](ISSUE_02_NO_TYPESCRIPT.md) (types + Zustand = powerful combo)
- [Remediation Phase 1](../INDUSTRY_STANDARDS_AUDIT.md#phase-1-foundation-weeks-1-2)

---

## Conclusion

**Props drilling is stealing your productivity.**

With centralized state management (Zustand):

- ‚úÖ Add new features 5√ó faster
- ‚úÖ Components become reusable and testable
- ‚úÖ No more &quot;which component has this state?&quot; confusion
- ‚úÖ Physics engine can access state directly
- ‚úÖ New developers understand state flow instantly

**Effort: 1-2 weeks**  
**Payback: Every week of development after that**

---

**Status:** Ready for implementation  
**Recommended solution:** Zustand  
**Priority:** High (unblocks other issues)  
**Timeline:** 1-2 weeks  
**Dependencies:** None (can start immediately)
</code></pre>
        </details>
      </section>
    
        </article>
      </main>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
  <script>
    // Lazy-load Kekule only when molecule viewer is expanded (saves bandwidth on low-end devices)
    (() => {
      let smilesDrawerLoaded = false
      let smilesDrawerLoading = false
      
      // Convert explicit SMILES like [CH3][CH](OH)[CH3] to standard like CC(O)C
      const explicitToStandard = (smiles) => {
        return smiles
          // Common organic groups - order matters (longer patterns first)
          .replace(/\[CH3\]/g, 'C')
          .replace(/\[CH2\]/g, 'C')
          .replace(/\[CH\]/g, 'C')
          .replace(/\[OH\]/g, 'O')
          .replace(/\[NH2\]/g, 'N')
          .replace(/\[NH\]/g, 'N')
          .replace(/\[SH\]/g, 'S')
          // Single atoms in brackets (keep aromatic lowercase)
          .replace(/\[C\]/g, 'C')
          .replace(/\[N\]/g, 'N')
          .replace(/\[O\]/g, 'O')
          .replace(/\[S\]/g, 'S')
          .replace(/\[P\]/g, 'P')
          .replace(/\[F\]/g, 'F')
          .replace(/\[Cl\]/g, 'Cl')
          .replace(/\[Br\]/g, 'Br')
          .replace(/\[I\]/g, 'I')
          // Bare atoms in branches - H is implicit in standard SMILES
          .replace(/\(OH\)/g, '(O)')
          .replace(/\(NH2\)/g, '(N)')
          .replace(/\(NH\)/g, '(N)')
          .replace(/\(SH\)/g, '(S)')
      }
      
      const loadSmilesDrawer = async () => {
        if (smilesDrawerLoaded) return
        if (smilesDrawerLoading) {
          return new Promise(resolve => {
            const check = setInterval(() => {
              if (smilesDrawerLoaded) { clearInterval(check); resolve() }
            }, 50)
          })
        }
        smilesDrawerLoading = true
        
        // Load SmilesDrawer from CDN (much simpler than Kekule)
        await new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = 'https://unpkg.com/smiles-drawer@2.1.7/dist/smiles-drawer.min.js'
          script.onload = resolve
          script.onerror = reject
          document.body.appendChild(script)
        })
        
        smilesDrawerLoaded = true
        smilesDrawerLoading = false
      }
      
      const initMolecule = async (node) => {
        if (node.dataset.initialized) return
        node.dataset.initialized = 'true'
        
        const rawSmiles = node.getAttribute('data-smiles')
        if (!rawSmiles) return
        
        // Convert explicit format to standard if needed
        const smiles = explicitToStandard(rawSmiles)
        
        try {
          await loadSmilesDrawer()
          
          const drawer = new SmilesDrawer.SvgDrawer({ 
            width: 300, 
            height: 200,
            explicitHydrogens: true,
            terminalCarbons: true,
            compactDrawing: false
          })
          
          console.log('Parsing SMILES:', rawSmiles, '->', smiles)
          SmilesDrawer.parse(smiles, (tree) => {
            console.log('Parse success, tree:', tree)
            const svgElement = drawer.draw(tree, null, 'light')
            console.log('SVG element:', svgElement)
            node.innerHTML = ''
            node.appendChild(svgElement)
          }, (err) => {
            console.error('SMILES parse error for "' + smiles + '":', err)
            node.innerHTML = '<code>' + rawSmiles + '</code>'
          })
        } catch (err) {
          console.error('SmilesDrawer load error:', err)
          node.innerHTML = '<code>' + smiles + '</code>'
        }
      }
      
      // Use IntersectionObserver for lazy loading when scrolled into view
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initMolecule(entry.target)
            observer.unobserve(entry.target)
          }
        })
      }, { rootMargin: '100px' })
      
      // Also handle <details> expansion for molecules inside collapsed sections
      document.addEventListener('toggle', (e) => {
        if (e.target.tagName === 'DETAILS' && e.target.open) {
          const molecules = e.target.querySelectorAll('[data-smiles]:not([data-initialized])')
          molecules.forEach(node => initMolecule(node))
        }
      }, true)
      
      // Observe all molecule nodes
      const init = () => {
        const nodes = document.querySelectorAll('[data-smiles]')
        nodes.forEach(node => observer.observe(node))
      }
      
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init)
      } else {
        init()
      }
    })()
  </script>
</body>
</html>