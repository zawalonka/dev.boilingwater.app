<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PHYSICS_TESTING_STRATEGY.md - Boiling Water Wiki</title>
  <link rel="stylesheet" href="/wiki/assets/styles.css" />
  <!-- Kekule CSS loaded lazily when molecule viewer is needed -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />
</head>
<body>
  <div class="wiki-layout">
    <div class="wiki-main">
      <header class="wiki-topbar">
        <details class="wiki-menu" aria-label="Menu">
          <summary>â˜° Menu</summary>
          <nav class="wiki-menu-links">
            <div class="menu-section">
              <div class="menu-heading">Main</div>
              <a href="/wiki/index.html">ğŸ“š Main page</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Science</div>
              <a href="/wiki/entities/elements/index.html">âš›ï¸ Elements</a>
              <a href="/wiki/entities/compounds/index.html">ğŸ§ª Compounds</a>
              <a href="/wiki/entities/solutions/index.html">ğŸ’§ Solutions</a>
              <a href="/wiki/entities/phases/index.html">â„ï¸ Phases</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Game Structure</div>
              <a href="/wiki/entities/levels/index.html">ğŸ“Š Levels</a>
              <a href="/wiki/entities/experiments/index.html">ğŸ”¬ Experiments</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Code Reference</div>
              <a href="/wiki/entities/formulas/index.html">ğŸ“ Formulas</a>
              <a href="/wiki/entities/processes/index.html">âš™ï¸ Processes</a>
              <a href="/wiki/entities/modules/index.html">ğŸ“¦ Modules</a>
              <a href="/wiki/entities/symbols/index.html">ğŸ”£ Symbols</a>
              <a href="/wiki/entities/public/index.html">ğŸ“ Public Files</a>
              <a href="/wiki/entities/assets/index.html">ğŸ–¼ï¸ Assets</a>
            </div>
            <div class="menu-section">
              <div class="menu-heading">Repository</div>
              <a href="/wiki/entities/docs/index.html">ğŸ“– Docs</a>
              <a href="/wiki/entities/scripts/index.html">ğŸ§° Scripts</a>
              <a href="/wiki/entities/styles/index.html">ğŸ¨ Styles</a>
              <a href="/wiki/entities/root-files/index.html">ğŸ—‚ï¸ Root Files</a>
            </div>
            <div class="wiki-menu-divider"></div>
            <a href="/">â¬…ï¸ Back to Game</a>
          </nav>
        </details>
        
        <nav class="breadcrumbs" aria-label="Breadcrumb">
          <a href="/wiki/../../../index.html">Main</a> <span class="breadcrumb-sep">â€º</span> <a href="/wiki/../index.html">Modules</a> <span class="breadcrumb-sep">â€º</span> <a href="/wiki/../docs/index.html">docs</a> <span class="breadcrumb-sep">â€º</span> <a href="/wiki/../docs/testing/index.html">testing</a> <span class="breadcrumb-sep">â€º</span> <span>PHYSICS_TESTING_STRATEGY.md</span>
        </nav>
        <div class="wiki-topbar-title">PHYSICS_TESTING_STRATEGY.md</div>
      </header>
      <main class="wiki-content">
        
        <article class="wiki-article">
          
      
    <aside class="infobox">
      <div class="infobox-title">PHYSICS_TESTING_STRATEGY.md</div>
      
      <div class="infobox-row">
        <div class="infobox-label">Type</div>
        <div class="infobox-value">Module</div>
      </div>
    
      <div class="infobox-row">
        <div class="infobox-label">File type</div>
        <div class="infobox-value">md</div>
      </div>
    
    </aside>
  
      <section class="section">
        
  <div class="entity-header">
    <h1>PHYSICS_TESTING_STRATEGY.md</h1>
    <p class="subtitle">Module</p>
  </div>

      </section>
      
      <section class="section" id="source-file">
        <h2>Source file</h2>
        <p><code>docs\testing\PHYSICS_TESTING_STRATEGY.md</code></p>
        <details>
          <summary>View source code</summary>
          <pre class="line-numbers"><code class="language-markdown"># Physics Testing Strategy for Scientific Sandbox

&gt; **Purpose**: Define HOW to test physics formulas without hardcoding magic numbers, while ensuring mathematical correctness for college students and field experts.
&gt;
&gt; **Last Updated**: 2026-02-04  
&gt; **Status**: âœ… APPROVED &amp; READY FOR IMPLEMENTATION  
&gt; **All Decisions Confirmed**: Temperature (Â±0.01Â°C), Energy (Dynamic 0.01%), edge cases, conservation laws

---

## ğŸ¯ Testing Philosophy for Scientific Sandbox

### Core Principle
**Test the formula implementation, not the result.**

Rather than:
```javascript
// âŒ BAD - Magic number, no formula verification
it(&#39;calculates heat&#39;, () =&gt; {
  expect(calculateHeat(100, 4.186, 50)).toBe(20930000)
})
```

Test this way:
```javascript
// âœ… GOOD - Verifies formula Q = mcÎ”T is actually implemented
it(&#39;heat calculation uses Q = mcÎ”T formula&#39;, () =&gt; {
  const mass = 100
  const specificHeat = 4.186
  const deltaT = 50
  const result = calculateHeat(mass, specificHeat, deltaT)
  
  // Manually compute formula to verify implementation
  const expectedFromFormula = mass * specificHeat * deltaT
  expect(result).toBeCloseTo(expectedFromFormula, 5)
})

// âœ… EXCELLENT - Verify scaling properties (no mocked numbers needed)
it(&#39;heat scales linearly with mass&#39;, () =&gt; {
  const heat1 = calculateHeat(50, 4.186, 50)
  const heat2 = calculateHeat(100, 4.186, 50)
  expect(heat2).toBeCloseTo(heat1 * 2, 10)  // Math property, not magic!
})
```

### Why This Works for Sandbox
- **No brittle hardcoded values**: If formula changes (new constants, better coefficients), tests still pass
- **Educational**: Tests verify the textbook formula is implemented, not just that results match yesterday&#39;s code
- **Scalable**: Works for extreme values (cryo, space, etc.) without pre-computing expected results
- **Field-expert friendly**: Physicists can validate formula implementation, not just numeric outputs

---

## ğŸ“Š Physics Functions by Category

### 1. **TEMPERATURE CONVERSIONS** (Formulas)
Files: `temperatureConversion.js`

**Functions**:
- `celsiusToFahrenheit(celsius)`
- `fahrenheitToCelsius(fahrenheit)`
- `celsiusToKelvin(celsius)`
- `kelvinToCelsius(kelvin)`

**Mathematical Properties to Test**:
```javascript
// âœ… Round-trip conversions must be reversible
C â†’ F â†’ C = C (within floating-point tolerance)

// âœ… Reference points (no magic numbers, just physics knowledge)
0Â°C = 32Â°F = 273.15K
100Â°C = 212Â°F = 373.15K
-40Â°C = -40Â°F  (only point where they&#39;re equal)
```

**Conservation Law**: Identity under round-trip â†’ verify reversibility
**Precision**: Â±0.01 acceptable (floating-point rounding)

---

### 2. **LATENT HEAT** (Phase Change Energy)
Files: `latentHeat.js`

**Functions**:
- `calculateVaporizationEnergy(massKg, vaporizationHeatPerMassKJ)`
- `calculateFusionEnergy(massKg, fusionHeatPerMassKJ)`

**Mathematical Properties to Test**:
```javascript
// âœ… Linear scaling with mass
Q = m Ã— Lv
Q(2m) = 2 Ã— Q(m)  // Linear property

// âœ… Linear scaling with latent heat constant
Q(Lv1) / Q(Lv2) = Lv1 / Lv2  // Proportional

// âœ… Energy always positive (or zero)
Q â‰¥ 0

// âœ… For water at STP: well-known values
Q(1kg water vaporization, 2257 kJ/kg) = 2,257,000 J
Q(1kg water fusion, 334 kJ/kg) = 334,000 J
```

**Conservation Law**: Energy conservation â†’ Q_out from burner = Q_in to phase change
**Critical for Sandbox**: Verify energy doesn&#39;t mysteriously vanish during vaporization

---

### 3. **HEAT CAPACITY** (Temperature Change)
Files: `heatCapacity.js`

**Functions**:
- `calculateTemperatureChange(energyJ, massKg, specificHeatJperKgK)`
- `calculateEnergy(massKg, specificHeatJperKgK, temperatureChangeK)`

**Mathematical Properties to Test**:
```javascript
// âœ… Formula: Q = mcÎ”T
Î”T = Q / (mc)
Q = m Ã— c Ã— Î”T

// âœ… Inverse relationship: More energy â†’ larger temp change
Q(50J) = temp_change_1
Q(100J) = temp_change_2
temp_change_2 / temp_change_1 â‰ˆ 100/50 = 2

// âœ… Scaling properties
Î”T(m=100) / Î”T(m=50) = 0.5  // Double mass â†’ half temp rise for same energy

// âœ… Physical bounds
Î”T â‰¥ 0 when Q â‰¥ 0
```

**Conservation Law**: Energy conservation â†’ Q_input = m Ã— c Ã— Î”T (exactly)
**Critical for Sandbox**: Temperature rise must be proportional to energy added

---

### 4. **NEWTON&#39;S LAW OF COOLING** (Heat Transfer)
Files: `newtonCooling.js`

**Functions**:
- `calculateTemperatureAtTime(T0, Tambient, kEffective, timeSeconds)`
- `calculateCoolingRate(tempDifference, kEffective)`

**Mathematical Properties to Test**:
```javascript
// âœ… Exponential decay: T(t) = Tambient + (T0 - Tambient) Ã— e^(-kt)

// âœ… Boundary conditions
T(0) = T0  (at t=0, temperature is initial)
T(âˆ) â†’ Tambient  (eventually reaches room temp)

// âœ… Faster cooling when temp difference is larger
rate(T=100, Troom=20) &gt; rate(T=30, Troom=20)

// âœ… No cooling when at equilibrium
T(t) = Tambient when T0 = Tambient  (for all t)

// âœ… Monotonic cooling (always decreasing if T0 &gt; Tambient)
If T0 &gt; Tambient, then T(t1) &gt; T(t2) for t1 &lt; t2
```

**Conservation Law**: Energy leaves object at rate proportional to temp difference
**Critical for Sandbox**: Must account for room temperature (hot water cools faster than cool water)

---

### 5. **ANTOINE EQUATION** (Vapor Pressure)
Files: `antoineEquation.js`

**Functions**:
- `calculateVaporPressure(celsius, coefficientsA_B_C, substance)`
- `calculateBoilingTemp(pressureMMHg, coefficientsA_B_C, substance)`

**Mathematical Properties to Test**:
```javascript
// âœ… Formula: logâ‚â‚€(Pvap) = A - B/(C + T)

// âœ… Monotonic increasing: Higher temp â†’ Higher vapor pressure
P(T1) &lt; P(T2)  for T1 &lt; T2

// âœ… Round-trip conversion (within Antoine accuracy)
T = calculateBoilingTemp(P)
P&#39; = calculateVaporPressure(T)
P&#39; â‰ˆ P  (Â±0.5 mmHg typical for water)

// âœ… Physical reference points (textbook values)
For water:
  P(100Â°C) â‰ˆ 760 mmHg
  P(0Â°C) â‰ˆ 4.6 mmHg
  P(50Â°C) â‰ˆ 92.5 mmHg

// âœ… Outside verified range: still works, just less accurate
Extrapolation returns metadata: { value, isExtrapolated: true }
```

**Conservation Law**: Equilibrium â†’ vapor pressure equals atmospheric pressure at boiling point
**Critical for Sandbox**: Allows boiling point calculations at any altitude

---

### 6. **DYNAMIC EBULLIOSCOPY (Colligative Properties)**
Files: `dynamicKb.js`, `ebullioscopy.js`

**Functions**:
- `calculateDynamicKb(boilingTempK, solventProps)`
- `calculateBoilingPointElevation(molality, dynamicKb)`

**Mathematical Properties to Test**:
```javascript
// âœ… Formula: Î”Tb = Kb Ã— m
Where Kb depends on temp (not static!)

// âœ… Non-negativity
Kb â‰¥ 0
Î”Tb â‰¥ 0 (boiling point only goes up with solute)

// âœ… Linear scaling with molality
Î”Tb(0.1m) / Î”Tb(0.2m) = 0.1/0.2  (linear proportionality)

// âœ… Verify temp-dependency: Kb changes with T
Kb(100Â°C) â‰  Kb(50Â°C)
```

**Conservation Law**: Boiling point elevation depends only on solute count, not identity (colligative property)
**Critical for Sandbox**: Explains why salt water boils higher than pure water

---

### 7. **ISA ATMOSPHERE MODEL** (Altitude/Pressure)
Files: `isaAtmosphere.js`

**Functions**:
- `calculatePressureAtAltitude(altitudeM, temperatureC)`
- `calculateTemperatureAtAltitude(altitudeM)`
- `calculateDensityAtAltitude(altitudeM)`

**Mathematical Properties to Test**:
```javascript
// âœ… Monotonic decreasing: Higher altitude â†’ Lower pressure
P(h1) &gt; P(h2)  for h1 &lt; h2

// âœ… Physical reference points
P(0m, sea level) â‰ˆ 101,325 Pa (1 atm)
P(~5,500m, Denver) â‰ˆ 83,500 Pa (~0.82 atm)
P(8,848m, Everest) â‰ˆ 33,700 Pa (~0.33 atm)

// âœ… Exponential decay (at least locally)
P decays exponentially in troposphere (steeper higher up)

// âœ… Pressure never negative
P(h) &gt; 0 for all altitudes
```

**Conservation Law**: Pressure decreases with altitude (hydrostatic equilibrium)
**Critical for Sandbox**: Explains why water boils at lower temp at altitude

---

### 8. **NEWTON&#39;S COOLING + HEATING + PHASE CHANGE** (Complex Process)
Files: `processes/heating/`, `processes/simulation/`

**Functions**:
- `simulateTimeStep(state, energyAdded, deltaTime, fluidProps)`
- `applyHeatEnergy(currentTemp, energyJ, massKg, heatCapacity, ...)`

**Mathematical Properties to Test**:
```javascript
// âœ… ENERGY CONSERVATION (most critical!)
// Total energy in = temp rise + heat loss to room + phase change energy
// Energy_in = Energy_temp_rise + Energy_cooling + Energy_vaporization

// âœ… Phase boundaries
// At 0Â°C (ice): won&#39;t heat above 0 until fusion complete
// At boiling point: won&#39;t heat above until vaporization complete

// âœ… Smoothness: No sudden jumps
d(Temperature)/d(Time) is continuous (except at phase transitions)

// âœ… Monotonicity when heating
If energy_in &gt; energy_loss: Temperature increases
If energy_in &lt; energy_loss: Temperature decreases

// âœ… No energy loss after phase change
Once water becomes steam at 100Â°C, no heat should be &quot;hidden&quot;
```

**Conservation Law**: First Law of Thermodynamics â†’ Energy in = Work out + Change in internal energy
**Critical for Sandbox**: Verify no mysterious energy loss during long simulations

---

## ğŸ§ª Proposed Test File Organization

```
src/utils/physics/__tests__/
â”œâ”€â”€ formulas/
â”‚   â”œâ”€â”€ temperatureConversion.test.js       (5 tests, &lt;10 min)
â”‚   â”œâ”€â”€ latentHeat.test.js                  (6 tests, &lt;10 min)
â”‚   â”œâ”€â”€ heatCapacity.test.js                (8 tests, &lt;10 min)
â”‚   â”œâ”€â”€ newtonCooling.test.js               (8 tests, &lt;15 min)
â”‚   â”œâ”€â”€ antoineEquation.test.js             (10 tests, &lt;20 min)
â”‚   â”œâ”€â”€ isaAtmosphere.test.js               (6 tests, &lt;15 min)
â”‚   â”œâ”€â”€ dynamicKb.test.js                   (4 tests, &lt;10 min)
â”‚   â””â”€â”€ ebullioscopy.test.js                (4 tests, &lt;10 min)
â””â”€â”€ processes/
    â”œâ”€â”€ heating.test.js                     (10 tests, &lt;25 min)
    â”œâ”€â”€ cooling.test.js                     (8 tests, &lt;20 min)
    â””â”€â”€ integration.test.js                 (6 tests, energy conservation, &lt;30 min)
```

**Total**: ~85 tests, ~3 hours implementation

---

## âš¡ Testing Strategy by Priority

### ğŸ”´ CRITICAL (Must test - sandbox breaks without this)
1. **Temperature Conversions** - Used everywhere
2. **Heat Capacity (Q = mcÎ”T)** - Core heating physics
3. **Latent Heat** - Phase transitions (water â†’ steam)
4. **Energy Conservation** - Verify no mysterious energy loss

### ğŸŸ  HIGH PRIORITY (Tests educational value)
5. **Newton&#39;s Cooling** - Explains room temperature effects
6. **Antoine Equation** - Explains altitude effects
7. **ISA Atmosphere** - Pressure at altitude

### ğŸŸ¡ MEDIUM PRIORITY (Tests sandbox extremes)
8. **Dynamic Kb** - Colligative properties (salt water, etc.)
9. **Ebullioscopy** - Boiling point elevation

### ğŸŸ¢ NICE-TO-HAVE (Tests corner cases)
10. **PID Controller** - AC/heating algorithm
11. **Diffusion** - Room air mixing
12. **Gas Exchange** - Air handler system

---

## ğŸ“‹ Test Case Template (No Hardcoded Values)

Each formula test file will follow this pattern:

```javascript
import { describe, it, expect } from &#39;vitest&#39;
import { calculateHeat } from &#39;../formulas/heatCapacity&#39;

describe(&#39;Heat Capacity Formula (Q = mcÎ”T)&#39;, () =&gt; {
  // âœ… TEST 1: Verify formula implementation
  it(&#39;implements Q = mcÎ”T correctly&#39;, () =&gt; {
    const m = 100
    const c = 4.186
    const deltaT = 50
    const result = calculateHeat(m, c, deltaT)
    const expectedFromFormula = m * c * deltaT
    expect(result).toBeCloseTo(expectedFromFormula, 5)
  })

  // âœ… TEST 2: Verify scaling property
  it(&#39;scales linearly with mass&#39;, () =&gt; {
    const heat1 = calculateHeat(50, 4.186, 50)
    const heat2 = calculateHeat(100, 4.186, 50)
    expect(heat2).toBeCloseTo(heat1 * 2, 10)
  })

  // âœ… TEST 3: Verify boundary condition
  it(&#39;returns zero energy when temperature change is zero&#39;, () =&gt; {
    expect(calculateHeat(100, 4.186, 0)).toBeCloseTo(0, 10)
  })

  // âœ… TEST 4: Verify energy conservation
  it(&#39;energy is never negative&#39;, () =&gt; {
    expect(calculateHeat(100, 4.186, 50)).toBeGreaterThan(0)
    expect(calculateHeat(100, 4.186, 0)).toBeGreaterThanOrEqual(0)
  })

  // âœ… TEST 5: Verify inverse relationship
  it(&#39;inverse relationship: Î”T = Q / (mc)&#39;, () =&gt; {
    const Q = calculateHeat(100, 4.186, 50)
    const recoveredDeltaT = Q / (100 * 4.186)
    expect(recoveredDeltaT).toBeCloseTo(50, 10)
  })
})
```

---

## âœ… CONFIRMED REVIEW DECISIONS (All Questions Answered)

### 1. **Precision/Tolerance** âœ… LOCKED
   - **Temperature conversions**: Â±0.01Â°C (2 decimal places) âœ…
   - **Heat calculations**: Dynamic 0.01% (`Math.max(1J, value * 0.0001)`) âœ…
   - **Pressure**: Â±0.5 mmHg âœ… (Antoine verification range)
   - **Antoine extrapolation**: YES + return metadata `{ value, isExtrapolated: true }` âœ…

### 2. **Edge Cases** âœ… CONFIRMED
   - **Negative temperatures (cryogenic)**: YES - Test extreme values (-196Â°C to 300Â°C) âœ…
   - **Zero mass**: THROW ERROR (physically invalid) âœ…
   - **Zero energy input**: Silently OK, return same temperature âœ…
   - **Extreme altitudes (space)**: YES - Handle gracefully, no artificial clamps âœ…

### 3. **Phase Transition Boundaries** âœ… CONFIRMED
   - **Exactly at boiling point**: Test both phases (edge case) âœ…
   - **During vaporization**: YES - Test temperature holding at boiling point âœ…
   - **Partial phase change**: YES - Test energy accounting with dynamic tolerance âœ…

### 4. **Room Temperature Effects** âœ… CONFIRMED
   - **Mock room state**: Not needed for formula tests, mock for integration tests âœ…
   - **Default room temp**: 20Â°C (standard) âœ…
   - **Test heating above/below room temp**: YES - Test both scenarios âœ…

### 5. **Conservation Law Testing** âœ… CONFIRMED
   - **Macro test**: YES - Create integration test for `Energy_in = Î”Temp_rise + Heat_loss + Phase_change_energy` âœ…
   - **Different burner powers**: YES - Test with varying energy inputs âœ…
   - **Time steps**: YES - Test 100-step simulation for energy drift âœ…

---

## ğŸ¯ IMPLEMENTATION READY

**Status**: âœ… ALL DECISIONS CONFIRMED - Ready to write tests  
**Test Count**: 48 core tests (Phase 1-3 in APPROVED_PLAN)  
**Time Estimate**: 4-5 hours implementation  
**Test Files**: 7 files (see PHYSICS_TESTING_APPROVED_PLAN.md for checklist)

**Next Action**: Begin Phase 1 (Core Formula Tests) - See [PHYSICS_TESTING_APPROVED_PLAN.md](./PHYSICS_TESTING_APPROVED_PLAN.md) for detailed implementation checklist.

---

**Status**: âœ… APPROVED &amp; FINALIZED  
**Cross-Reference**: [PHYSICS_TESTING_APPROVED_PLAN.md](./PHYSICS_TESTING_APPROVED_PLAN.md)  
**Author**: GitHub Copilot (AI-assisted)  
**Last Updated**: 2026-02-04
</code></pre>
        </details>
      </section>
    
        </article>
      </main>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
  <script>
    // Lazy-load Kekule only when molecule viewer is expanded (saves bandwidth on low-end devices)
    (() => {
      let smilesDrawerLoaded = false
      let smilesDrawerLoading = false
      
      // Convert explicit SMILES like [CH3][CH](OH)[CH3] to standard like CC(O)C
      const explicitToStandard = (smiles) => {
        return smiles
          // Common organic groups - order matters (longer patterns first)
          .replace(/\[CH3\]/g, 'C')
          .replace(/\[CH2\]/g, 'C')
          .replace(/\[CH\]/g, 'C')
          .replace(/\[OH\]/g, 'O')
          .replace(/\[NH2\]/g, 'N')
          .replace(/\[NH\]/g, 'N')
          .replace(/\[SH\]/g, 'S')
          // Single atoms in brackets (keep aromatic lowercase)
          .replace(/\[C\]/g, 'C')
          .replace(/\[N\]/g, 'N')
          .replace(/\[O\]/g, 'O')
          .replace(/\[S\]/g, 'S')
          .replace(/\[P\]/g, 'P')
          .replace(/\[F\]/g, 'F')
          .replace(/\[Cl\]/g, 'Cl')
          .replace(/\[Br\]/g, 'Br')
          .replace(/\[I\]/g, 'I')
          // Bare atoms in branches - H is implicit in standard SMILES
          .replace(/\(OH\)/g, '(O)')
          .replace(/\(NH2\)/g, '(N)')
          .replace(/\(NH\)/g, '(N)')
          .replace(/\(SH\)/g, '(S)')
      }
      
      const loadSmilesDrawer = async () => {
        if (smilesDrawerLoaded) return
        if (smilesDrawerLoading) {
          return new Promise(resolve => {
            const check = setInterval(() => {
              if (smilesDrawerLoaded) { clearInterval(check); resolve() }
            }, 50)
          })
        }
        smilesDrawerLoading = true
        
        // Load SmilesDrawer from CDN (much simpler than Kekule)
        await new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = 'https://unpkg.com/smiles-drawer@2.1.7/dist/smiles-drawer.min.js'
          script.onload = resolve
          script.onerror = reject
          document.body.appendChild(script)
        })
        
        smilesDrawerLoaded = true
        smilesDrawerLoading = false
      }
      
      const initMolecule = async (node) => {
        if (node.dataset.initialized) return
        node.dataset.initialized = 'true'
        
        const rawSmiles = node.getAttribute('data-smiles')
        if (!rawSmiles) return
        
        // Convert explicit format to standard if needed
        const smiles = explicitToStandard(rawSmiles)
        
        try {
          await loadSmilesDrawer()
          
          const drawer = new SmilesDrawer.SvgDrawer({ 
            width: 300, 
            height: 200,
            explicitHydrogens: true,
            terminalCarbons: true,
            compactDrawing: false
          })
          
          console.log('Parsing SMILES:', rawSmiles, '->', smiles)
          SmilesDrawer.parse(smiles, (tree) => {
            console.log('Parse success, tree:', tree)
            const svgElement = drawer.draw(tree, null, 'light')
            console.log('SVG element:', svgElement)
            node.innerHTML = ''
            node.appendChild(svgElement)
          }, (err) => {
            console.error('SMILES parse error for "' + smiles + '":', err)
            node.innerHTML = '<code>' + rawSmiles + '</code>'
          })
        } catch (err) {
          console.error('SmilesDrawer load error:', err)
          node.innerHTML = '<code>' + smiles + '</code>'
        }
      }
      
      // Use IntersectionObserver for lazy loading when scrolled into view
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initMolecule(entry.target)
            observer.unobserve(entry.target)
          }
        })
      }, { rootMargin: '100px' })
      
      // Also handle <details> expansion for molecules inside collapsed sections
      document.addEventListener('toggle', (e) => {
        if (e.target.tagName === 'DETAILS' && e.target.open) {
          const molecules = e.target.querySelectorAll('[data-smiles]:not([data-initialized])')
          molecules.forEach(node => initMolecule(node))
        }
      }, true)
      
      // Observe all molecule nodes
      const init = () => {
        const nodes = document.querySelectorAll('[data-smiles]')
        nodes.forEach(node => observer.observe(node))
      }
      
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init)
      } else {
        init()
      }
    })()
  </script>
</body>
</html>