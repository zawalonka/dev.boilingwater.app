/**
 * SUBSTANCE CATALOG GENERATOR
 * 
 * Scans filesystem for all substances and generates dynamic import catalog.
 * Runs automatically before every build (dev/production).
 * 
 * Output: src/generated/substanceCatalog.js (auto-generated, do not edit)
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..')

// Paths
const COMPOUNDS_DIR = path.join(projectRoot, 'src/data/substances/compounds')
const ELEMENTS_DIR = path.join(projectRoot, 'src/data/substances/periodic-table')
const OUTPUT_DIR = path.join(projectRoot, 'src/generated')
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'substanceCatalog.js')

console.log('üîç Scanning for substances...')

// Helper to recursively find info.json files
function findCompounds(dir) {
  const compounds = {}
  
  function scanDir(currentDir, relativePath = '') {
    const entries = fs.readdirSync(currentDir, { withFileTypes: true })
    
    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name)
      const relPath = path.join(relativePath, entry.name)
      
      if (entry.isDirectory()) {
        // Check if this directory has info.json
        const infoPath = path.join(fullPath, 'info.json')
        if (fs.existsSync(infoPath)) {
          try {
            const data = JSON.parse(fs.readFileSync(infoPath, 'utf-8'))
            // Use the ID from the JSON file, not the folder name
            const compoundId = data.id || entry.name
            compounds[compoundId] = {
              displayName: data.name || compoundId,
              category: data.category || 'compound',
              path: `../data/substances/compounds/${relPath}/info.json`.replace(/\\/g, '/'),
              folderPath: relPath.replace(/\\/g, '/')  // Store for phase state loading
            }
          } catch (error) {
            console.warn(`‚ö†Ô∏è  Failed to read ${entry.name}: ${error.message}`)
          }
        } else {
          // Recurse into subdirectory
          scanDir(fullPath, relPath)
        }
      }
    }
  }
  
  scanDir(dir)
  return compounds
}

// Scan for compounds
const compounds = findCompounds(COMPOUNDS_DIR)

// Scan for element files
const elementFiles = fs.readdirSync(ELEMENTS_DIR).filter(f => f.endsWith('.json'))
const elements = {}

for (const file of elementFiles) {
  // Extract element symbol from filename: 001_H_nonmetal.json -> H
  const match = file.match(/^(\d{3})_([A-Z][a-z]?)_/)
  if (!match) continue
  
  const [, atomicNum, symbol] = match
  const fullPath = path.join(ELEMENTS_DIR, file)
  
  // Read element metadata for display name
  try {
    const data = JSON.parse(fs.readFileSync(fullPath, 'utf-8'))
    const displayName = data.name || symbol
    
    elements[symbol] = {
      displayName,
      category: 'element',
      atomicNumber: parseInt(atomicNum),
      path: `../data/substances/periodic-table/${file}`
    }
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Failed to read element ${symbol}: ${error.message}`)
  }
}

console.log(`‚úÖ Found ${Object.keys(compounds).length} compounds`)
console.log(`‚úÖ Found ${Object.keys(elements).length} elements`)

// Generate catalog file with LAZY dynamic imports
// Substances are loaded only when requested (better performance)
const catalogContent = `/**
 * AUTO-GENERATED SUBSTANCE CATALOG
 * 
 * Generated by: scripts/generateSubstanceCatalog.js
 * Generated at: ${new Date().toISOString()}
 * 
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY
 * This file is regenerated on every build.
 * 
 * Discovered substances:
 * - ${Object.keys(compounds).length} compounds
 * - ${Object.keys(elements).length} elements
 */

// ============================================================================
// COMPOUND LOADERS (lazy - loaded on demand)
// ============================================================================

export const compoundLoaders = {
${Object.entries(compounds).map(([id, data]) => 
  `  '${id}': () => import('${data.path}')`
).join(',\n')}
}

// ============================================================================
// ELEMENT LOADERS (lazy - loaded on demand)
// ============================================================================

export const elementLoaders = {
${Object.entries(elements).map(([symbol, data]) => 
  `  '${symbol}': () => import('${data.path}')`
).join(',\n')}
}

// ============================================================================
// METADATA (for UI dropdowns and display names)
// ============================================================================

export const compoundMetadata = {
${Object.entries(compounds).map(([id, data]) => 
  `  '${id}': { displayName: '${data.displayName}', category: '${data.category}', folderPath: '${data.folderPath}' }`
).join(',\n')}
}

export const elementMetadata = {
${Object.entries(elements).map(([symbol, data]) => 
  `  '${symbol}': { displayName: '${data.displayName}', category: '${data.category}', atomicNumber: ${data.atomicNumber} }`
).join(',\n')}
}

// ============================================================================
// DISCOVERY FUNCTIONS
// ============================================================================

/**
 * Get all available compound IDs
 */
export function getAvailableCompounds() {
  return Object.keys(compoundLoaders)
}

/**
 * Get all available element symbols
 */
export function getAvailableElements() {
  return Object.keys(elementLoaders)
}

/**
 * Get all available substance IDs (compounds + elements)
 */
export function getAvailableSubstances() {
  return [...getAvailableCompounds(), ...getAvailableElements()]
}
`

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true })
  console.log(`üìÅ Created directory: ${OUTPUT_DIR}`)
}

// Write catalog file
fs.writeFileSync(OUTPUT_FILE, catalogContent, 'utf-8')
console.log(`üìù Generated: ${OUTPUT_FILE}`)
console.log('‚ú® Substance catalog generated successfully!')
